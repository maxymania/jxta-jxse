<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE>JXTA v2.0 Protocols Specification</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.1  (Win32)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="J&eacute;r&ocirc;me Verstrynge">
	<META NAME="CHANGED" CONTENT="20100106;16371100">
	<META NAME="DESCRIPTION" CONTENT="The JXTA protocols defines a suite of six XML-based protocols that standardize the manner in which peers self-organize into peergroups, publish and discover peer resources, communicate, and monitor each other. The Endpoint Routing Protocol (ERP) is the protocol by which a peer can discover a route (sequence of hops) to send a message to another peer potentially traversing firewalls and NATs. The Rendezvous Protocol (RVP) is used for propagating a message within a peergroup. The Peer Resolver Protocol (PRP) is the protocol used to send a generic query to one or more peers, and receive a response (or multiple responses) to the query. The Peer Discovery Protocol (PDP) is used to publish and discover resource advertisements. The Peer Information Protocol (PIP) is the protocol by a which a peer may obtain status information about another peers. The Pipe Binding Protocol (PBP) is the protocol by which a peer can establish a virtual communication channel or pipe between one or more peers. The JXTA protocols permit the establishment a virtual network overlay on top of physical networks allowing peers to directly interact and organize independently of their network location and connectivity. The JXTA protocols have been designed to be easily implemented on unidirectional links and asymmetric transports.">
	<META NAME="KEYWORDS" CONTENT="JXTA, www.jxta.org, http://www.jxta.org, P2P, Communications Protocol, peer-to-peer, peer-2-peer">
	<STYLE TYPE="text/css">
	<!--
		TD P { color: #000000; font-family: serif; text-align: justify }
		H1 { color: #000000; text-align: justify }
		P { color: #000000; font-family: serif; text-align: justify }
		H1.title { font-family: sans-serif }
		H3 { color: #000000; text-align: justify }
		TH P { color: #000000; font-family: serif }
		P.title { font-family: sans-serif; font-weight: bold }
		DT { color: #000000; font-family: serif; text-align: justify }
		DD { color: #000000; font-family: serif; text-align: justify }
		H2 { color: #000000; text-align: justify }
		H2.title { font-family: sans-serif }
		PRE { color: #000000; text-align: justify }
		PRE.programlisting { background: #eeeeee; border: 1px solid #000000; padding: 0.5cm; font-family: monospace }
		H3.title { font-family: sans-serif }
		H4 { color: #000000; text-align: justify }
		H4.title { font-family: sans-serif }
		A:link { color: #0000ff }
		A:visited { color: #840084 }
	-->
	</STYLE>
</HEAD>
<BODY LANG="fr-BE" TEXT="#000000" LINK="#0000ff" VLINK="#840084" BGCOLOR="#ffffff" DIR="LTR">
<H1 LANG="en" CLASS="title"><A NAME="id281638"></A>JXTA v2.0
Protocols Specification</H1>
<H3><SPAN LANG="en">Project JXTA <A HREF="http://www.jxta.org/" TARGET="_top">http://jxta.kenai.com</A></SPAN></H3>
<P LANG="en">Copyright &copy; 2001-2010 Sun Microsystems Inc.</P>
<P LANG="en">Copyright &copy; 2002, 2003, 2004 The Internet Society.
All Rights Reserved.</P>
<P LANG="en"><A NAME="id281771"></A><FONT FACE="monospace">This
document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any
kind, provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.</FONT></P>
<P LANG="en"><FONT FACE="monospace">The limited permissions granted
above are perpetual and will not be revoked by the Internet Society
or its successors or assigns.</FONT></P>
<P><FONT FACE="monospace"><SPAN LANG="en">This document and the
information contained herein is provided on an &quot;</SPAN></FONT><EM><FONT FACE="monospace"><SPAN LANG="en">AS
IS</SPAN></FONT></EM><FONT FACE="monospace"><SPAN LANG="en">&quot;
basis and </SPAN></FONT><EM><FONT FACE="monospace"><SPAN LANG="en">THE
INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS
ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.</SPAN></FONT></EM></P>
<P LANG="en">2006</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TH COLSPAN=3 VALIGN=TOP>
			<P ALIGN=LEFT><B>Revision History</B></P>
		</TH>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 22, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>goober@jxta.org,</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>preliminary DocBook format</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.2</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>September 22, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>goober@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>first release based on DocBook format (no intended
			changes from 1.2 revision)</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.3</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>November 20, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to the IDs chapter to document new IDs
			design. Information on components provided as part of reference
			implementations is also being moved to the reference
			implementation section (this may eventually be a separate
			document).</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.4</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>November 20, 2001</P>
		</TD>
		<TD>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to Protocol chapter, discovery behavior and
			minor changes to the Resolver section.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.5</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>November 21, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to Advertisements chapter, added sections
			for ModuleClassAdvertisement, ModuleSpecAdvertisement,
			ModuleImplAdvertisement. Updated sections for PeerAdvertisement
			and PeerGroupAdvertisement.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.6</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>November 28, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to Advertisements chapter, added sections
			for PeerInfoAdvertisement. also includes typo corrections in
			various sections</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.7</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>November 29, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to the Protocol Section, and more
			description on PeerInfoAdvertisement traffic field</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.8</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>December, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Integrated docbookized version of Eric's sections
			about enpoint service and router. Made some cosmetic fixes per
			last review.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.9</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>December 4, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to protocols chapter to use schemas to
			describe message structure more formally. Remove Peer Membership
			Protocol. Remove Content Advertisement (may be readded in
			documentation of CMS, but not part of or used by core protocols)
			Minor cosmetic improvements to copyright and ids chapter.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.10</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>December 7, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to protocols chapter to use mores schemas to
			describe message structure more formally. Examples for each as
			well.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.11</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>December 7, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>More updates to the protocols chapter. Converting
			raw program listings to figures and examples, addition of live
			cross references. Preparing for glossary and bibliography.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.12</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>December 9, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>More updates to the protocols chapter.
			PeerInfoProtocol and Pipe Binding Protocol now have schemas.
			Converting raw program listings to figures and examples, addition
			of live cross references. Preparing for glossary and bibliography.
			Cosmetic changes to Messages chapter</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.2.13</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>December 17, 2001</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Peer Info Protocol was redone because the previous
			schema though XML-like, was not representable with XML. (Endpoint
			Addresses as tag names were the culprit). PIP now looks more like
			the Peer Discovery Protocol with separate schemas for query and
			response. Document has been restructured into three major
			sections; Core Specification, Standard Services, and Reference
			Implementations. This restructuring makes understanding the JXTA
			Protocols more straight-forward because requirements and
			behaviours are now divided between functionality required by all
			JXTA peers, functionality needed to interoperate with the optional
			JXTA Protocols, and functionality required to interoperate with
			specific JXTA implementations.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>January 3, 2002</P>
		</TD>
		<TD>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Wrote introductions for each of the new document
			sections. Introduced a glossary and bibliography. More
			restructuring of the source docbook files. Changes to prepare for
			a printable form document.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.1</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>January 9, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Spelling and grammar corrections. More
			reorganization of material into core, standard services and
			reference implementation parts. Updating stylesheets and docbook
			usage based on techniques seen in other docbook projects.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.2</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>January 9, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>More moving content around into core and standard
			services. More chapters reorganized. New text in advertisments
			chapter. More bibliographic information.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.3</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>January 14, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Redid the schemas for the advertisement chapter.
			Moved all of the protocol advertisements and schemas to the
			appropriate protocols chapters. Use of &lt;literal&gt; has now
			been replaced with &lt;phrase&gt; and a role attribute of <EM>rfc2119</EM>.
			Improved field descriptions for some of the core advertisements.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.4</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>February 13, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Lots of minor revisions based on review cycle.
			Thanks to all of the reviewers who took time to review and
			respond!</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.5</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>April 19, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Redid some of the schema descriptions in a new and
			clearer style, more will be converted of over time. Redid schemas
			and examples for Pipe Binding Protocol section. A few changes to
			FO generation which generates <EM>much</EM>better PDF output.
			Corrected a few specific issues pointed out by Brendon Wilson.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.6</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 10, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>More complete documentation of the Pipe Binding
			Protocol based upon review of the J2SE and C implementations.
			Partial re-write of the Messages chapter to flesh out some of the
			details. Remove text not specific to the protocol (mostly dealing
			with namespace &quot;:&quot; name).</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.7</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 11, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Minor corrections following review. Now has an
			&quot;Abstract&quot; section.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.3.8</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 18, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Lots of corrections following a detailed review by
			Jeff Altman, with many more corrections to come! A bit of
			reorganisation of the messages chapter into two pieces. Some
			cleanups for TOC generation in the HTML version. Still working on
			SVG figures. Next release will be 1.4 upon completion of all the
			feedback cleanups.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.4</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 19, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>The Docbook source now validates against the Docbook
			4.2 DTD. This seemingly minor issue fixed a number of problems
			with the HTML, PDF and rfc 2629 renderings and cross-referencing.
			Implemented all of the feedback from the most recent review cycle.
			Fixed a number of the figures.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.4.1</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 21, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>More revisions following careful review. This
			version is being released to coincide with the submission of the
			JXTA Specification as an Internet-Draft to IETF.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 1.4.2</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>October 10, 2002</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to Standard Transports sections. Updates to
			the Endpoint Routing Protocol and Endpoint Router Transport. Adds
			new optional SRDI message for Endpoint Resolver Protocol. Minor
			textual improvements and clarifications elsewhere. New examples
			and figures.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.0</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>February 27, 2003</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Updates to Standard Transports sections.
			Clarifications in the IDs section. Updates to the Pipe Resolver
			protocol. Minor textual improvements and clarifications elsewhere.
			Added a section on &quot;Users and Peers&quot;. Added a number of
			glossary terms. More contributions to the glossary are welcome.
			Updated version to &quot;2.0&quot;. Rewrote or revised much of the
			Overview chapter.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.1.1</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>October 15, 2003</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Additional updates to the Introduction and Overview
			chapters. Many additions to the glossary section. Minor schema
			corrections.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.2.1</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>April 10th, 2004</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Additional updates to glossary and bibliography.
			Added updates to pipes regarding propagate pipes.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.3</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 30th, 2004</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Additional information about the Rendezvous,
			Resolver and Pipe Services.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.3.5</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>September 20th, 2005</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>mathieu@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Homogeneous spec for Resolver queries and responses.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.5</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>June 23rd, 2006</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Clarifications to the HTTP Message Transport.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.5.1</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>August 23rd, 2006</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Corrections and clarifications to Route
			Advertisement and Pipe Resolver Message.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.5.2</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>January 9th, 2007</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Corrections and clarifications from several sharp
			eyed readers. Now includes complete specification of Binary
			Message Format version 2 and specification of the endpoint
			SrcAddess and DstAddress message elements.</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT>Revision 2.5.3</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>October 16th, 2007</P>
		</TD>
		<TD>
			<P ALIGN=LEFT>bondolo@jxta.org</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P ALIGN=LEFT>Additional glossary entries and other minor
			corrections.</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en" CLASS="title"><B>Abstract</B></P>
<P LANG="en">The JXTA protocols defines a suite of six XML-based
protocols that standardize the manner in which peers self-organize
into peergroups, publish and discover peer resources, communicate,
and monitor each other. The Endpoint Routing Protocol (ERP) is the
protocol by which a peer can discover a route (sequence of hops) to
send a message to another peer potentially traversing firewalls and
NATs. The Rendezvous Protocol (RVP) is used for propagating a message
within a peergroup. The Peer Resolver Protocol (PRP) is the protocol
used to send a generic query to one or more peers, and receive a
response (or multiple responses) to the query. The Peer Discovery
Protocol (PDP) is used to publish and discover resource
advertisements. The Peer Information Protocol (PIP) is the protocol
by a which a peer may obtain status information about another peers.
The Pipe Binding Protocol (PBP) is the protocol by which a peer can
establish a virtual communication channel or pipe between one or more
peers. The JXTA protocols permit the establishment a virtual network
overlay on top of physical networks allowing peers to directly
interact and organize independently of their network location and
connectivity. The JXTA protocols have been designed to be easily
implemented on unidirectional links and asymmetric transports.</P>
<HR>
<DL>
	<DT><SPAN LANG="en"><A HREF="#id283589">1. Conventions</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#id283566">1.1. Significant Keywords</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id283970">1.2. Text Representations</A> </SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#introduction">2. Introduction</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#id283731">2.1. Why JXTA?</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id284292">2.2. The JXTA Protocols</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id284627">2.3. The JXTA Three Layer Cake</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id284676">2.4. JXTA Assumptions</A> </SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#id285729">3. Conceptual Overview</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#id285706">3.1. Peers</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#overview-peergroups">3.2. Peer Groups</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#overview-services">3.3. Network Services</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#overview-ids">3.4. IDs</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#overview-advertisements">3.5.
		Advertisements</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id286669">3.6. Credentials</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#overview-pipes">3.7. Pipes</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id287021">3.8. Messages</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#overview-codats">3.9. Codats</A> </SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#core">1. JXTA Core Specification</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#ids">1. IDs</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-i">1.1.
			Introduction</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-jip">1.2. JXTA
			ID Properties</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-ujip">1.3.
			Using JXTA IDs in Protocols</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-fjiu">1.4.
			Format of a JXTA ID URN</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-ejiu">1.5.
			Example JXTA ID URNs</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#id288806">1.6.
			JXTA ID Representation</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-jif">1.7. JXTA
			ID Formats</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-jit">1.8. JXTA
			ID Types</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#ids-jinf">1.9.
			JXTA ID Formats : &ldquo;jxta&rdquo; ID Format</A> </SPAN></FONT>
			</DT></DL>
		<DT>
		<SPAN LANG="en"><A HREF="#core-advert">2. Advertisements</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-i">2.1.
			Introduction</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-x">2.2. XML
			and JXTA Advertisements</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-pa">2.3.
			Peer Advertisement</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-pga">2.4.
			Peer Group Advertisement</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-mca">2.5.
			Module Class Advertisement</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-msa">2.6.
			Module Specification Advertisement</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#advert-mia">2.7.
			Module Implementation Advertisement</A> </SPAN></FONT>
			</DT></DL>
		<DT>
		<SPAN LANG="en"><A HREF="#core-proto">3. JXTA Core Protocols</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#proto-prp">3.1.
			Peer Resolver Protocol</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#proto-erp">3.2.
			Endpoint Routing Protocol</A> </SPAN></FONT>
			</DT></DL>
		<DT>
		<SPAN LANG="en"><A HREF="#core-trans">4. Core JXTA Message
		Transport Bindings</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#trans-endpt">4.1.
			Endpoint Service</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#trans-router">4.2.
			Endpoint Router Transport Protocol</A> </SPAN></FONT>
			</DT></DL>
		<DT>
		<SPAN LANG="en"><A HREF="#msgs">5. Messages</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#id295839">5.1.
			Introduction</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#id296192">5.2.
			Message</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#id296221">5.3.
			Element</A> </SPAN></FONT>
			</DT></DL>
	</DL>
	<DT>
	<SPAN LANG="en"><A HREF="#stdsvc">2. JXTA Standard Services</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#stdsvc-proto">1. Standard Protocols</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#proto-pdp">1.1.
			Peer Discovery Protocol</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#proto-rvp">1.2.
			Rendezvous Protocol</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#proto-pip">1.3.
			Peer Information Protocol</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#proto-pbp">1.4.
			Pipe Binding Protocol</A> </SPAN></FONT>
			</DT></DL>
		<DT>
		<SPAN LANG="en"><A HREF="#stdsvc-trans">2. Standard JXTA Message
		Transports</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#trans-tcpipt">2.1.
			TCP/IP Message Transport</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#trans-httpt">2.2.
			HTTP Message Transport</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#trans-tlst">2.3.
			TLS Transport Binding</A> </SPAN></FONT>
			</DT></DL>
		<DT>
		<SPAN LANG="en"><A HREF="#msgs-fmts">3. JXTA Message Wire
		Representations</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#id310772">3.1.
			General Requirements</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#msgs-fmts-jbm">3.2.
			Binary Message Format</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#id311199">3.3. XML
			Message Format</A> </SPAN></FONT>
			</DT></DL>
	</DL>
	<DT>
	<SPAN LANG="en"><A HREF="#refimpls">3. JXTA Reference
	Implementations Information</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#refimpl-j2se">1. Java 2 SE Reference
		Implementation</A> </SPAN>
		</DT><DL>
			<DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#refimpl-j2se-ids">1.1.
			JXTA ID Formats</A> </SPAN></FONT>
			</DT><DT STYLE="text-align: justify">
			<FONT COLOR="#000000"><SPAN LANG="en"><A HREF="#trans-router-refimpl">1.2.
			J2SE JXTA Endpoint Router Implementation</A> </SPAN></FONT>
			</DT></DL>
	</DL>
	<DT>
	<SPAN LANG="en"><A HREF="#id320945">Glossary</A> </SPAN>
	</DT><DT STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en"><A HREF="#id322024">Bibliography</A> </SPAN>
	</DT></DL>
<P LANG="en">
<B>List of Figures</B></P>
<DL>
	<DT><SPAN LANG="en">1. <A HREF="#intro-fjp">JXTA Protocols</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2. <A HREF="#id286970">JXTA Pipe Types</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.1. <A HREF="#ids-fjia">JXTA ID ABNF</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.2. <A HREF="#ids-fjifa">JXTA ID : &quot;jxta&quot;
	ID Format ABNF</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.1. <A HREF="#fpcafs">Common Advertisement
	Fragments Schemas</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.2. <A HREF="#fpas">Peer Advertisement Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.3. <A HREF="#fpgas">Peer Group Advertisement
	Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.4. <A HREF="#fmcas">Module Class Advertisement
	Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.5. <A HREF="#fmsas">Module Specification
	Advertisement Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.6. <A HREF="#fmias">Module Implementation
	Advertisement Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.1. <A HREF="#frqs">Resolver Query Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.2. <A HREF="#frrs">Resolver Response Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.3. <A HREF="#frsrdis">Resolver SRDI Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.4. <A HREF="#flnsa">Listener Naming Syntax ABNF</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">3.5. <A HREF="#id293298">Endpoint Address URI ABNF</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">3.6. <A HREF="#feprra">Route Advertisement</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.7. <A HREF="#feprq">Endpoint Router Query</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.8. <A HREF="#feprrm">Endpoint Router Response
	Message</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">4.1. <A HREF="#feprme">Endpoint Router Message
	Element</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">4.2. <A HREF="#fjera">JXTA Endpoint Router Address
	Format</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.1. <A HREF="#fdqs">Discovery Query Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.2. <A HREF="#fdrs">Discovery Response Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.3. <A HREF="#fras">Rendezvous Advertisement Schema</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.4. <A HREF="#fpvm">PeerView Message</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.5. <A HREF="#fpvms">PeerView Message Scenarios</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.6. <A HREF="#frpms">RendezVous Propagate Message
	Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.7. <A HREF="#fpipqs">PIP Query Message</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.8. <A HREF="#fpiprs">PIP Response Message</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.9. <A HREF="#fpipeas">Pipe Advertisement Schema</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.10. <A HREF="#fprms">Pipe Resolver Message Schema</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.11. <A HREF="#fwhms">Propagate Pipe Message Header
	Schema</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.1. <A HREF="#id307872">Welcome Message ABNF</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.2. <A HREF="#id308004">JXTA Message Package ABNF</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">3.1. <A HREF="#fjbmabnf">JXTA Binary Message Version
	1 ABNF</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.2. <A HREF="#fjbmabnf2">JXTA Binary Message
	Version 2 ABNF</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.1. <A HREF="#ids-fuifa">JXTA &quot;uuid&quot; ID
	Format ABNF</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.2. <A HREF="#id317979">JXTA UUID Codat ID Fields</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.3. <A HREF="#id318142">JXTA UUID PeerGroup ID
	Fields</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.4. <A HREF="#id318277">JXTA UUID Peer ID Fields</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.5. <A HREF="#id318412">JXTA UUID Pipe ID Fields</A>
	</SPAN>
	</DT><DT>
	<SPAN LANG="en">1.6. <A HREF="#id318645">JXTA UUID Module Class ID
	Fields</A> </SPAN>
	</DT><DT STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">1.7. <A HREF="#id318773">JXTA UUID Module Spec ID
	Fields</A> </SPAN>
	</DT></DL>
<P LANG="en">
<B>List of Examples</B></P>
<DL>
	<DT><SPAN LANG="en">1.1. <A HREF="#ids-e">Sample JXTA IDs</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.1. <A HREF="#frqe">Resolver Query</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.2. <A HREF="#frre">Resolver Response</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.3. <A HREF="#frsrdie">Resolver SRDI</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.4. <A HREF="#id293326">Endpoint Address URI
	Examples</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.1. <A HREF="#fdqe">Discovery Query</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.2. <A HREF="#fdre">Discovery Response</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">1.3. <A HREF="#fpipeae">Pipe Advertisement</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.1. <A HREF="#id307972">Welcome Message</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.2. <A HREF="#id308272">HTTP Ping Example</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.3. <A HREF="#id308557">HTTP Poll Example</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">2.4. <A HREF="#id308735">HTTP Send Example</A> </SPAN>
	</DT><DT>
	<SPAN LANG="en">3.1. <A HREF="#msgs-exm">XML Message</A> </SPAN>
	</DT><DT STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">1.1. <A HREF="#id317933">Sample &quot;uuid&quot;
	Format ID</A> </SPAN>
	</DT></DL>
<H2 LANG="en" CLASS="title">
<A NAME="id283589"></A>Conventions</H2>
<P LANG="en">The following conventions are used throughout this
document.</P>
<H2 LANG="en" CLASS="title"><A NAME="id283566"></A>1.1.&nbsp;Significant
Keywords</H2>
<P><SPAN LANG="en">The key words must, must not, required, shall,
shall not, should, should not, recommended, not recommended, may, and
optional in this document are to be interpreted as described in &ldquo;IETF
RFC 2119&rdquo; <A HREF="#bib-RFC2119">RFC2119</A>.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="id283970"></A>1.2.&nbsp;Text
Representations</H2>
<P><SPAN LANG="en">All strings and text found in the JXTA Protocols
should be assumed to be encoded using Unicode <A HREF="#bib-USA28">USA28</A>
Canonical UTF8 (NFC) (see </SPAN><EM><SPAN LANG="en">Unicode Standard
Annex #15 : Unicode Normalization Forms</SPAN></EM><SPAN LANG="en">
<A HREF="#bib-USA15">USA15</A>) unless otherwise specified.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="introduction"></A>Introduction</H2>
<H2 LANG="en" CLASS="title"><A NAME="id283731"></A>2.1.&nbsp;Why
JXTA?</H2>
<P><SPAN LANG="en">The </SPAN><EM><A HREF="#gloss-jxta"><SPAN LANG="en">JXTA</SPAN></A></EM><SPAN LANG="en">
Protocols comprise an open network computing platform designed for
peer-to-peer (P2P) computing. The set of generalized JXTA protocols
enable all connected devices on the network -- including cell phones,
</SPAN><SPAN LANG="en">PDA</SPAN><SPAN LANG="en">s, PCs and servers
-- to communicate and collaborate as peers. The JXTA protocols enable
developers to build and deploy interoperable services and
applications, further spring-boarding the peer-to-peer revolution on
the Internet.</SPAN></P>
<P LANG="en">The JXTA protocols standardize the manner in which
peers:</P>
<UL TYPE=DISC>
	<LI><P LANG="en">Discover each other</P>
	<LI><P LANG="en">Self-organize into peer groups</P>
	<LI><P LANG="en">Advertise and discover network resources</P>
	<LI><P LANG="en">Communicate with each other</P>
	<LI><P LANG="en">Monitor each other</P>
</UL>
<P><SPAN LANG="en">The JXTA protocols are designed to be independent
of the underlying implementation. In particular, the JXTA protocols
</SPAN><EM><SPAN LANG="en">do not</SPAN></EM><SPAN LANG="en">:</SPAN></P>
<UL TYPE=DISC>
	<LI><P LANG="en">Require the use of any particular computer language
	or operating system.</P>
	<LI><P LANG="en">Require the use of any particular network transport
	or topology.</P>
	<LI><P LANG="en">Require the use of any particular authentication,
	security or encryption model.</P>
</UL>
<P LANG="en">JXTA provides a simple and generic P2P platform with all
the basic functions necessary to host all types of network services:</P>
<UL TYPE=DISC>
	<LI><P LANG="en">JXTA is defined by a small number of protocols.
	Each protocol is easy to implement and integrate into P2P services
	and applications. Thus, service offerings from one vendor can be
	used transparently by the user community of another vendor's system.</P>
	<LI><P LANG="en">The JXTA protocols are defined to be independent of
	programming languages, so that they can be implemented in C/C++,
	Java, Perl, and numerous other languages. Heterogeneous devices with
	completely different software stacks can interoperate using the JXTA
	protocols.</P>
	<LI><P LANG="en">The JXTA protocols are designed to be independent
	of transport protocols. They can be implemented on top of TCP/IP,
	HTTP, Bluetooth, HomePNA, and many other protocols.</P>
</UL>
<H2 LANG="en" CLASS="title"><A NAME="id284292"></A>2.2.&nbsp;The JXTA
Protocols</H2>
<P LANG="en">The JXTA protocols are a set of six protocols that have
been specifically designed for ad hoc, pervasive, and multi-hop
peer-to-peer (P2P) network computing. Using the JXTA protocols, peers
can cooperate to form self-organized and self-configured peer groups
independent of their positions in the network (edges, firewalls,
network address translators, public vs. private address spaces), and
without the need of a centralized management infrastructure.</P>
<P LANG="en">The JXTA protocols are designed to have very low
overhead, make few assumptions about the underlying network transport
and impose few requirements on the peer environment, and yet are able
to be used to deploy a wide variety of P2P applications and services
in a highly unreliable and changing network environment.</P>
<P LANG="en">Peers use the JXTA protocols to advertise their
resources and to discover network resources (services, pipes, etc.)
available from other peers. Peers form and join peer groups to create
special relationships. Peers cooperate to route messages allowing for
full peer connectivity. The JXTA protocols allow peers to communicate
without the need to understand or manage the potentially complex and
dynamic network topologies which are increasingly common.</P>
<P LANG="en">The JXTA protocols allow peers to dynamically route
messages across multiple network hops to any destination in the
network (potentially traversing firewalls). Each message carries with
it either a complete or partially ordered list of gateway peers
through which the message might be routed. Intermediate peers in the
route may assist the routing by using routes they know of to shorten
or optimize the route a message is set to follow.</P>
<P LANG="en">The JXTA protocols are composed of six protocols that
work together to allow the discovery, organization, monitoring and
communication between peers:</P>
<UL TYPE=DISC>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#proto-prp">Peer
	Resolver Protocol</A> (</SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">)
	is the mechanism by which a peer can send a query to one or more
	peers, and receive a response (or multiple responses) to the query.
	The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en"> implements a
	query/response protocol. The response message is matched to the
	query via a unique id included in the message body. Queries can be
	directed to the whole group or to specific peers within the group. </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#proto-pdp">Peer
	Discovery Protocol</A> (</SPAN><SPAN LANG="en">PDP</SPAN><SPAN LANG="en">)
	is the mechanism by which a peer can advertise its own resources,
	and discover the resources from other peers (peer groups, services,
	pipes and additional peers). Every peer resource is described and
	published using an advertisement. Advertisements are programming
	language-neutral metadata structures that describe network
	resources. Advertisements are represented as XML documents. </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#proto-pip">Peer
	Information Protocol</A> (</SPAN><SPAN LANG="en">PIP</SPAN><SPAN LANG="en">)
	is the mechanism by a which a peer may obtain status information
	about other peers. This can include state, uptime, traffic load,
	capabilities, and other information. </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#proto-pbp">Pipe
	Binding Protocol</A> (</SPAN><SPAN LANG="en">PBP</SPAN><SPAN LANG="en">)
	is the mechanism by which a peer can establish a virtual
	communication channel or pipe between one or more peers. The PBP is
	used by a peer to bind two or more ends of the connection (pipe
	endpoints). Pipes provide the foundation communication mechanism
	between peers. </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#proto-erp">Endpoint
	Routing Protocol</A> (</SPAN><SPAN LANG="en">ERP</SPAN><SPAN LANG="en">)
	is the mechanism by which a peer can discover a route (sequence of
	hops) used to send a message to another peer. If a peer &ldquo;A&rdquo;wants
	to send a message to peer &ldquo;C&rdquo;, and there is no known
	direct route between &ldquo;A&rdquo;and &ldquo;C&rdquo;, then peer
	&ldquo;A&rdquo;needs to find intermediary peer(s) who will route the
	message to &ldquo;C&rdquo;. ERP is used to determine the route
	information. If the network topology changes and makes a previously
	used route unavailable, peers can use ERP to find an alternate
	route. </SPAN>
	</P>
	<LI><P><SPAN LANG="en"><A HREF="#proto-rvp">Rendezvous Protocol</A>
	(</SPAN><SPAN LANG="en">RVP</SPAN><SPAN LANG="en">) is the mechanism
	by which peers can subscribe or be a subscriber to a propagation
	service. Within a peer group, peers can be either rendezvous peers
	or peers that are listening to rendezvous peers. The Rendezvous
	Protocol allows a peer to send messages to all the listening
	instances of the service. The RVP is used by the Peer Resolver
	Protocol and by the Pipe Binding Protocol in order to propagate
	messages. </SPAN>
	</P>
</UL>
<P><SPAN LANG="en">All of these protocols are implemented using a
common messaging layer. This messaging layer is what binds the JXTA
protocols to various network transports. (see <A HREF="#msgs">Messages</A>)</SPAN></P>
<P LANG="en">Each of the JXTA protocols is independent of the others.
A peer is not required to implement all of the JXTA protocols to be a
JXTA peer. A peer only implements the protocols that it needs to use.
For example:</P>
<UL TYPE=DISC>
	<LI><P LANG="en">A device may have all the necessary advertisements
	it uses pre-stored in memory, and therefore not need to implement
	the Peer Discovery Protocol.</P>
	<LI><P LANG="en">A peer may use a pre-configured set of router peers
	to route all its messages. Because the peer just sends messages to
	the known routers to be forwarded, it does not need to fully
	implement the Endpoint Routing Protocol.</P>
	<LI><P LANG="en">A peer may not need to obtain or wish to provide
	status information to other peers, hence the peer might not
	implement the Peer Information Protocol.</P>
</UL>
<P><SPAN LANG="en">Each peer must implement two protocols in order to
be addressable as a peer: the Peer Resolver Protocol and the Endpoint
Routing Protocol. These two protocols and the advertisements,
services and definitions they depend upon are known as the </SPAN><EM><A HREF="#gloss-jcs"><SPAN LANG="en">JXTA
Core Specification</SPAN></A></EM><SPAN LANG="en">. The <A HREF="#core">JXTA
Core Specification</A> establishes the base infrastructure used by
other services and applications.</SPAN></P>
<P><SPAN LANG="en">The remaining JXTA protocols, services and
advertisements are optional. JXTA implementations are not required to
provide these services, but are strongly recommended to do so.
Implementing these services provides greater interoperability with
other implementations and broader functionality. These common JXTA
services are known as the </SPAN><EM><A HREF="#gloss-jss"><SPAN LANG="en">JXTA
Standard Services</SPAN></A></EM><SPAN LANG="en">.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="intro-fjp"></A><B>Figure&nbsp;1.&nbsp;JXTA
Protocols</B></P>
<PRE CLASS="programlisting">  <SPAN LANG="en">+------------------------+     +------------------------+</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|  | Peer Information | &lt;-------&gt; | Peer Information |  |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|                        |     |                        |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|  | Peer Rendezvous  | &lt;-------&gt; | Peer Rendezvous  |  |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|                        |     |                        |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|  | Pipe Binding     | &lt;-------&gt; | Pipe Binding     |  |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|                        |     |                        |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|  | Peer Discovery   | &lt;-------&gt; | Peer Discovery   |  |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|Peer                    |     |Peer                    |</SPAN>
  <SPAN LANG="en">+------------------------+     +------------------------+</SPAN>

  <SPAN LANG="en">+------------------------+     +------------------------+</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|  | Peer Resolver    | &lt;-------&gt; | Peer Resolver    |  |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|                        |     |                        |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|  | Endpoint Routing | &lt;-------&gt; | Endpoint Routing |  |</SPAN>
  <SPAN LANG="en">|  +------------------+  |     |  +------------------+  |</SPAN>
  <SPAN LANG="en">|Endpoint                |     |Endpoint                |</SPAN>
  <SPAN LANG="en">+------------------------+     +------------------------+</SPAN>

  <SPAN LANG="en">+------------------------+     +------------------------+</SPAN>
  <SPAN LANG="en">|       Transport        |     |      Transport         |</SPAN>
  <SPAN LANG="en">+------------------------+     +------------------------+</SPAN></PRE><P>
<BR><BR>
</P>
<P LANG="en">A peer may decide to cache advertisements discovered via
the Peer Discovery Protocol for later usage. It is important to point
out that caching is not required by the JXTA architecture, but
caching can be an important optimization. By caching advertisements,
a peer avoids the need to perform a new discovery each time it
accesses a network resource. In highly-transient environment,
performing the discovery is the only viable solution. In static
environments, caching is more efficient.</P>
<P LANG="en">A unique characteristic of P2P networks, like JXTA, is
their ability to spontaneously replicate information toward
end-users. Popular advertisements are likely to be replicated more
often, making them easier to find as more copies become available.
Peers do not have to return to the same peer to obtain the
advertisements they seek. Instead of querying the original source of
an advertisement, peers may query neighboring peers that have already
cached the information. Each peer may potentially become an
advertisement provider to any other peer.</P>
<P LANG="en">The JXTA protocols have been designed to allow JXTA to
be easily implemented on uni-directional links and asymmetric
transports. In particular, many forms of wireless networking do not
provide equal capability for devices to send and receive. JXTA
permits any uni-directional link to be used when necessary, improving
overall performance and network connectivity in the system. The
intent is for the JXTA protocols to be as pervasive as possible, and
easy to implement on any transport. Implementations on reliable and
bi-directional transports such as TCP/IP or HTTP should lead to
efficient bi-directional communications.</P>
<P LANG="en">The JXTA uni-directional and asymmetric transport also
plays well in multi-hop network environments where the message
latency may be difficult to predict. Furthermore, peers in a P2P
network tend to have nondeterministic behaviours. They may join or
leave the network on a very frequent basis.</P>
<H2 LANG="en" CLASS="title"><A NAME="id284627"></A>2.3.&nbsp;The JXTA
Three Layer Cake</H2>
<P LANG="en">The JXTA Project is logically divided in three layers.</P>
<UL TYPE=DISC>
	<LI><P><EM><SPAN LANG="en">Platform.</SPAN></EM><SPAN LANG="en">
	This layer encapsulates minimal and essential primitives that are
	common to P2P networking, including peers, peer groups, discovery,
	communication, monitoring, and associated security primitives. This
	layer is ideally shared by all P2P devices so that interoperability
	becomes possible.</SPAN></P>
	<LI><P><EM><SPAN LANG="en">Services.</SPAN></EM><SPAN LANG="en">
	This layer includes network services that may not be absolutely
	necessary for a P2P network to operate but are common or desirable
	for P2P environments. Examples of network services include search
	and indexing, directory, storage systems, file sharing, distributed
	file systems, resource aggregation and renting, protocol
	translation, authentication and PKI services.</SPAN></P>
	<LI><P><EM><SPAN LANG="en">Applications.</SPAN></EM><SPAN LANG="en">
	This layer includes P2P instant messaging, entertainment content
	management and delivery, P2P E-mail systems, distributed auction
	systems, and many others. Obviously, the boundary between services
	and applications is not rigid. An application to one customer can be
	viewed as a service to another customer.</SPAN></P>
</UL>
<H2 LANG="en" CLASS="title"><A NAME="id284676"></A>2.4.&nbsp;JXTA
Assumptions</H2>
<P LANG="en">This section is a guide to the assumptions that shape
the JXTA design. There are two types of assumptions stated here:
those which describe the requirements of JXTA implementations and
those which describe the expected behaviour of the JXTA network.</P>
<P LANG="en">A peer shall not make assumptions about the runtime
environments or programming languages in use by another peer. The
network of peers reachable by any peer is likely to contain many
peers with heterogeneous implementations and capabilities.</P>
<P LANG="en">A peer should assume that the capabilities and
complexity of the network peers supporting these protocols can range
from a single light switch to a highly-available supercomputer
cluster.</P>
<P LANG="en">A peer must implement the JXTA protocols such that all
interaction with other peers is correct and conformant.</P>
<P LANG="en">A peer may implement only the JXTA protocols it requires
for correct and conformant interaction with other peers.</P>
<P LANG="en">A peer may choose to partially implement protocols if
unimplemented portions will never be used. (e.g. it may implement
client-side or server-side portions only.)</P>
<P LANG="en">Peers wishing to interact with other peers within the
JXTA network should be willing to participate fully in the protocols.
In particular, peers should cache advertisements and forward messages
for other peers in the JXTA network. However, this participation is
optional.</P>
<P LANG="en">The JXTA protocols may be deployed over a wide variety
of network configurations including the Internet, corporate
intranets, a dynamic proximity network, or in a home networking
environment. Applications should avoid assumptions about the
underlying network environment.</P>
<P LANG="en">Peers receiving a corrupted or detectably compromised
message must discard the message. Messages may be corrupted or
intentionally altered during network transmission.</P>
<P LANG="en">Peers may appear, disappear and migrate at any time
without notice. In particular, the JXTA protocols support very
arbitrary environment changes allowing a peer to dynamically discover
and reconnect to its changing environment.</P>
<P LANG="en">The communication path between any pair of peers may at
times not work equally well in both directions. That is,
communications between two peers will in many cases be able to
operate bi-directionally, but at times the connection between two
peers may be only uni-directional, allowing one peer to successfully
send messages to the other while no communication is possible in the
reverse direction.</P>
<P LANG="en">The JXTA protocols are defined as idempotent protocol
exchanges. The same messages may be sent/received more than once
during the course of a protocol exchange. No protocol states are
required to be maintained at both ends.</P>
<P><SPAN LANG="en">Due to unpredictability of P2P networks,
assumptions must not be made about the time required for a message to
reach a destination peer. The <A HREF="#core-proto">JXTA Core
Protocols</A> must not impose any timing requirements for message
receipt.</SPAN></P>
<P><SPAN LANG="en">The JXTA Transport Protocols (see <A HREF="#core-trans">Core
JXTA Message Transport Bindings</A> and <A HREF="#stdsvc-trans">Standard
JXTA Message Transports</A>) must not impose any timing requirements
on the <A HREF="#core-proto">JXTA Core Protocols</A>, but may have
timing requirements internal to themselves.</SPAN></P>
<P><SPAN LANG="en">The <A HREF="#stdsvc-proto">Standard Protocols</A>
(e.g. <A HREF="#proto-pdp">Peer Discovery Protocol</A>, <A HREF="#proto-pip">Peer
Information Protocol</A>, <A HREF="#proto-pbp">Peer Discovery
Protocol</A>, etc.) and application defined protocols may impose
timing requirements on message delivery and receipt.</SPAN></P>
<P LANG="en">A JXTA protocol message which is routed through multiple
hops should not be assumed to reliably delivered, even if only
reliable transports such as TCP/IP are used through all hops. A
congested peer may drop messages at any time rather than routing
them.</P>
<P LANG="en">JXTA protocol messages and advertisements are defined
using XML and are required to be well-formed XML documents. The use
of a full XML parser is optional as long as the requirements of the
being well-formed and the JXTA protocol are met. Small JXTA
implementations may choose to use pre-built XML or XML templates for
message and advertisement construction.</P>
<P LANG="en">The JXTA protocols must not require a broadcast or
multicast capability of the underlying network transport. Messages
intended for receipt by multiple peers (propagation) may be
implemented using point-to-point communications.</P>
<P LANG="en">A peer should make the assumption that if a destination
address is not available at any time during the message transmission,
the message will not be delivered.</P>
<P LANG="en">A peer must not assume that there is a guaranteed return
route to a peer from which it has received communication. The lack of
a return route may either be temporary or permanent.</P>
<P LANG="en">Each peer must be a member of the World Peergroup and
Net Peergroups. Membership in these groups is automatic.</P>
<P LANG="en">Peers must be members of the same peer group in order to
exchange messages.</P>
<P LANG="en">Names are not unique unless a coordinated naming service
is used to guarantee name uniqueness. A naming service is typically a
service that guarantees, within a given scope, the uniqueness of name
and can be used to register name mapping. Examples of name services
are DNS and LDAP. A naming service is optional. JXTA does not define
its own naming service.</P>
<P LANG="en">Once content has been published to the JXTA network, it
should not be assumed that that the content can be later retrieved
from the JXTA network. The content may be available only from peers
that are not currently reachable.</P>
<P LANG="en">Once a content has been published to the JXTA network,
it must not be assumed that the content can be deleted. Republication
of content by peers is unrestricted and the content may propagate to
peers which are not reachable from the publishing peer.</P>
<H2 LANG="en" CLASS="title"><A NAME="id285729"></A>Conceptual
Overview</H2>
<P LANG="en">JXTA is intended to be a small system with a limited
number of concepts at its core. This chapter introduces the concepts
which are central to JXTA.</P>
<H2 LANG="en" CLASS="title"><A NAME="id285706"></A>3.1.&nbsp;Peers</H2>
<P><SPAN LANG="en">A JXTA peer is any networked device (sensor,
phone, </SPAN><SPAN LANG="en">PDA</SPAN><SPAN LANG="en">, </SPAN><SPAN LANG="en">PC</SPAN><SPAN LANG="en">,
server, supercomputer, etc.) that implements the core JXTA protocols.
Each peer is identified by a unique ID. Peers are autonomous and
operate independently and asynchronously of all other peers. Some
peers may have dependencies upon other peers due to special
requirements such as the need for gateways, proxies, or routers.</SPAN></P>
<P><SPAN LANG="en">Peers may publish network services and resources (
</SPAN><SPAN LANG="en">CPU</SPAN><SPAN LANG="en">, storage,
databases, documents, etc.) for use by other peers. A peer may cache
advertisements for JXTA resources, but doing so is optional. Peers
may have persistent storage.</SPAN></P>
<P LANG="en">Peers are typically configured to spontaneously discover
each other on the network to form transient or persistent
relationships with other peers. Peers that provide the same set of
services tend to be interchangeable. As a result, peers typically
need to interact with only a small number of other peers (network
neighbors or buddy peers). Peers should not make assumptions about
the reliability of other peers. Peers may join or leave the network
at any time. A peer should always anticipate that connectivity may be
lost to any peer that it is currently communicating with.</P>
<P LANG="en">Peers may advertise multiple network interfaces. Each
published interface is advertised as a peer endpoint. A peer endpoint
is a URI that uniquely identify a peer network interface (for
example, a URI might specify a TCP port and associated IP address).
Peer endpoints are used by peers to establish direct point-to-point
connections between two peers.</P>
<P LANG="en">Communicating peers are not required to have direct
point-to-point network connection between themselves. A peer may need
to use one or more intermediary peers to route a message to another
peer that is separated due to physical network connections or network
configurations (e.g., NATs, firewalls, or proxies).</P>
<H3 LANG="en" CLASS="title"><A NAME="id286143"></A>3.1.1.&nbsp;Peers
and Users</H3>
<P LANG="en">There is no explicit relationship between users and
peers within JXTA, but for many applications the two concepts are
closely related.</P>
<P LANG="en">Frequently a peer will be under the control of a human
operator, the &ldquo;user&rdquo;, and will interact with the network
on the basis of the user's direction. However, not every peer has an
associated user. Many peers exist to provide services and resources
to the network, but are not associated with any user. Examples
include devices such as sensors and printers, and services such as
databases.</P>
<P LANG="en">The concept of &ldquo;user&rdquo; exists primarily for
identification: some applications may need to allow users to tell
each other apart and to manage their interactions. Identity is also
frequently tied to security and permissions.</P>
<H2 LANG="en" CLASS="title"><A NAME="overview-peergroups"></A>3.2.&nbsp;Peer
Groups</H2>
<P LANG="en">Peers self-organize into Peer Groups. A peer group is a
collection of peers that have a common set of interests. Each peer
group is uniquely identified by a PeerGroup Id. The JXTA protocols do
not dictate when, where, or why peer groups are created. The JXTA
protocols only describe how peers may publish, discover, join, and
monitor peer groups.</P>
<P LANG="en">JXTA recognizes three common motivations for creating
peer groups:</P>
<UL TYPE=DISC>
	<LI><P><EM><SPAN LANG="en">To create a secure environment.</SPAN></EM><SPAN LANG="en">
	Peer group boundaries permit member peers to access and publish
	protected contents. Peer groups form logical regions whose
	boundaries limit access to the peer group resources. A peer group
	does not necessarily reflect the underlying physical network
	boundaries such as those imposed by routers and firewalls. Peer
	groups virtualize the notion of routers and firewalls, subdividing
	the network into secure regions without respect to actual physical
	network boundaries.</SPAN></P>
	<LI><P><EM><SPAN LANG="en">To create a scoping environment.</SPAN></EM><SPAN LANG="en">
	Peer groups are typically formed and self-organized based upon the
	mutual interest of peers. No particular rules are imposed on the way
	peer groups are formed, but peers with the same interests will tend
	to join the same peer groups. Peer groups serve to subdivide the
	network into abstract regions providing an implicit scoping
	mechanism. Peer group boundaries define the search scope when
	searching for a group's content.</SPAN></P>
	<LI><P><EM><SPAN LANG="en">To create a monitoring environment.</SPAN></EM><SPAN LANG="en">
	Peer groups permit peers to monitor a set of peers for any special
	purpose, including heartbeat, traffic introspection, and
	accountability.</SPAN></P>
</UL>
<P LANG="en">A peer group provides a set of services called peer
group services. JXTA defines a core set of peer group services, and
the JXTA protocols specify the wire format for these services.
Additional peer group services can be developed for delivering
specific services. For example, a lookup service could be implemented
to find active (running on some peer) and inactive (not yet running)
service instances. The core peer group services are:</P>
<DL>
	<DT LANG="en">Discovery Service 
	</DT><DD LANG="en">
	The Discovery service is used by member peers to search for peer
	group resources such as peers, peer groups, pipes, and services. 
	</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Membership Service 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The membership service is used by the current peer group members to
	reject or accept a new group membership application (i.e., to allow
	a new peer to join a peer group). We expect that most peer groups
	will have a membership service, though it may be a
	&ldquo;null&rdquo;authenticator service which imposes no real
	membership policy.</DD><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Peers wanting to join a peer group may need to discover at least one
	member of the peer group and then request to join. The request to
	join is either rejected or accepted by the collective set of current
	members. The membership service may enforce a vote of peers or elect
	a designated group representative to accept or reject new membership
	requests.</DD><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A peer may belong to more than one peer group simultaneously.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Access Service 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The Access service is used to validate requests made by one peer to
	another. The peer receiving the request provides the requesting peer
	credentials and information about the request being made to the
	Access Service to determine if the access is permitted.</DD><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Not all actions within the peer group need to be checked with the
	Access Service. Only those actions that are restricted to a subset
	of member peers must be checked.</DD><DT LANG="en">
	Pipe Service 
	</DT><DD LANG="en">
	The pipe service is used to manage and create pipe connections
	between the different peer group members. 
	</DD><DT LANG="en">
	Resolver Service 
	</DT><DD LANG="en">
	The resolver service is used to address queries to services running
	on peers in the group and collect responses. 
	</DD><DT LANG="en">
	Monitoring Service 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The monitoring service is used to allow one peer to monitor other
	members of the same peer group. 
	</DD></DL>
<P LANG="en">
Not all the above services must be implemented by a peer group. A
peer group can implement only the services it finds useful and rely
on the default Net Peergroup to provide generic implementations of
other services.</P>
<P LANG="en">Each service may implement one or more of the JXTA
protocols, the specifications for which are the main content of this
document. A service will typically implement one protocol for
simplicity and modularity reasons, but some services may not
implement any protocols.</P>
<H2 LANG="en" CLASS="title"><A NAME="overview-services"></A>3.3.&nbsp;Network
Services</H2>
<P LANG="en">Peers cooperate and communicate to publish, discover and
invoke network services. A peer can publish as many services as it
can provide. Peers discover network services via the Peer Discovery
Protocol.</P>
<P LANG="en">Network Service specifications are beyond the scope of
this document. Upcoming standards such as WSDL, ebXML, SOAP, UPnP
might be used within a JXTA Network.</P>
<P LANG="en">The JXTA protocols recognize two levels of network
services:</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Peer Services 
	</P>
	<LI><P LANG="en">Peer Group Services 
	</P>
</UL>
<P LANG="en">A peer service is accessible only on the peer that is
publishing the service. If that peer happens to fail, then the
service also fails. Multiple instances of the service can be run on
different peers, but each instance publishes its own advertisement.</P>
<P LANG="en">A peer group service is composed of a collection of
instances (potentially cooperating with each other) of the service
running on multiple members of the peer group. If any one peer fails,
the collective peer group service is not affected: in most cases, the
service is still available from another peer member. Peer group
services are published as part of the peer group advertisement.</P>
<P LANG="en">Services can either be pre-installed into a peer or
loaded from the network. The process of finding, downloading and
installing a service from the network is similar to performing a
search on the internet for a web page, retrieving the page, and then
installing the required plug-in. In order to actually run a service,
a peer may need to locate an implementation suitable for the peer's
runtime environment. Multiple implementations of the same service may
allow Java peers to use Java code implementations, and native peers
to use native code implementations.</P>
<H3 LANG="en" CLASS="title"><A NAME="id286524"></A>3.3.1.&nbsp;Service
Invocation</H3>
<P LANG="en">Service invocation is outside the scope of JXTA. JXTA is
designed to interoperate and be compatible with any Web service
standards: WSDL, uPnP, RMI, etc. The JXTA protocols define a generic
framework to publish and discover advertisements that may describe
services. Peers publish and discover advertisements via the Peer
Discovery Protocol. An advertisement for a service typically contains
all necessary information to either invoke or instantiate the service
being described. The JXTA protocols define Module Advertisements, but
any other form of service description may be introduced.</P>
<H3 LANG="en" CLASS="title"><A NAME="id286539"></A>3.3.2.&nbsp;JXTA-Enabled
Services</H3>
<P LANG="en">JXTA-Enabled services are services that are published
using a ModuleSpecAdvertisement. A ModuleSpecAdvertisement may
specify a pipe advertisement that can be used by a peer to create
output pipes to invoke the service. ModuleSpecAdvertisements may be
extended in the future to contain a list of pre-determined messages
that can be sent by a peer to interact with the service. A
ModuleSpecAdvertisement may also contain references to two other
services that can be used as an authenticator for the service and as
a local proxy for the service.</P>
<P LANG="en">Each JXTA-enabled service is uniquely identified by its
ModuleSpecID.</P>
<H2 LANG="en" CLASS="title"><A NAME="overview-ids"></A>3.4.&nbsp;IDs</H2>
<P LANG="en">Peers, peer groups, pipes, contents, and other resources
need to be uniquely identifiable within the JXTA protocols. A JXTA ID
uniquely identifies an entity and serves as a canonical means of
referring to that entity.</P>
<P LANG="en">URNs are used for the expression of JXTA IDs.</P>
<H2 LANG="en" CLASS="title"><A NAME="overview-advertisements"></A>3.5.&nbsp;Advertisements</H2>
<P LANG="en">All network resources, such as peers, peer groups, pipes
and services, are represented by advertisements. Advertisements are
JXTA's language neutral metadata structures for describing resources.
The JXTA Core Specification and Standard Services define, among
others, the following advertisement types:</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Peer Advertisement 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">PeerGroup Advertisement 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">ModuleClass
	Advertisement 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">ModuleSpec Advertisement
		</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">ModuleImpl Advertisement
		</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Pipe Advertisement 
	</P>
	<LI><P LANG="en">Rendezvous Advertisement 
	</P>
</UL>
<P><SPAN LANG="en">The complete specification of advertisements is
given in the <A HREF="#core-advert">Advertisements</A> chapter.
Because the JXTA protocols make heavy reference to these
advertisements, the reader should be familiar with advertisements
before moving on to the protocol specification chapters.
Advertisements are, by far, the most common document exchanged in the
protocol messages.</SPAN></P>
<P LANG="en">Advertisments are published with a lifetime that
specifies the availability of the resource. An advertisement can be
republished to extend the lifetime of a resource.</P>
<P LANG="en">Services and peer implementations can create their own
advertisement types, either from scratch or by subtyping the existing
types.</P>
<H2 LANG="en" CLASS="title"><A NAME="id286669"></A>3.6.&nbsp;Credentials</H2>
<P LANG="en">The need to support different levels of resource access
in a dynamic and ad hoc P2P network leads to a role-based trust model
in which an individual peer acts under the authority granted to it by
another trusted peer to perform a particular task. Peer relationships
may change quickly and the policies governing access control need to
be flexible in allowing or denying access.</P>
<P LANG="en">Four basic security requirements must be provided:</P>
<DL>
	<DT LANG="en">Confidentiality 
	</DT><DD LANG="en">
	Guarantees that the contents of the message are not disclosed to
	unauthorized individuals. 
	</DD><DT LANG="en">
	Authorization 
	</DT><DD LANG="en">
	Guarantees that the sender is authorized to send a message. 
	</DD><DT LANG="en">
	Data integrity 
	</DT><DD LANG="en">
	Guarantees that the message was not accidentally or deliberately
	modified in transit. 
	</DD><DT LANG="en">
	Refutability 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Guarantees the message was transmitted by a properly identified
	sender and is not a replay of a previously transmitted message. 
	</DD></DL>
<P LANG="en">
The structure of JXTA messages enables JXTA applications to add
arbitrary metadata information, such as credentials, digests,
certificates, and public keys, to messages. Message digests guarantee
the data integrity of messages. Messages may also be encrypted and
signed for confidentiality and refutability. Credentials can be used
to provide message authentication and authorization.</P>
<P LANG="en">A credential is a token that, when presented in a
message body, is used to identify a sender and can be used to verify
that sender's right to send the message to the specified endpoint.
The credential is an opaque token that must be presented each time a
message is sent. The sending address placed in the message envelope
is cross-checked with the sender's identity in the credential. Each
credential's implementation is specified as a plug-in configuration,
which allows multiple authentication configurations to co-exist on
the same network.</P>
<P LANG="en">It is the intent of the JXTA protocols to be compatible
with widely accepted transport-layer security mechanisms. Some JXTA
implementations contain a virtualized TLS implementation that allows
it to secure endpoint-to-endpoint communications regardless of the
number of hops required to deliver each message.</P>
<P LANG="en">TLS and IPSec could also be used as JXTA transports.
However, when used as transports they provide integrity and
confidentiality of message transfer only between the two
communicating peers.</P>
<H2 LANG="en" CLASS="title"><A NAME="overview-pipes"></A>3.7.&nbsp;Pipes</H2>
<P LANG="en">Pipes are virtual communication channels used to send
and receive messages between services or applications. Pipes provide
the illusion of a virtual in and out mailbox that is independent of
any single peer location, and independent of network topology
(multi-hops route).</P>
<P LANG="en">Different quality of services can be implemented by a
pipe. For example:</P>
<DL>
	<DT LANG="en">Uni-directional asynchronous 
	</DT><DD LANG="en">
	The endpoint sends a message, no guarantee of delivery is made. 
	</DD><DT LANG="en">
	Synchronous request-response 
	</DT><DD LANG="en">
	The endpoint sends a message, and receives a correlated answer. 
	</DD><DT LANG="en">
	Bulk transfer 
	</DT><DD LANG="en">
	Bulk reliable data transfer of binary data. 
	</DD><DT LANG="en">
	Streaming 
	</DT><DD LANG="en">
	Efficient control-flow data transfer. 
	</DD><DT LANG="en">
	Secure 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Secure reliable data streams. 
	</DD></DL>
<P LANG="en">
The uni-directional asynchronous pipe is required by the JXTA
protocols. Other pipe variations may be implemented for use by
services and their associated protocols.</P>
<P LANG="en">Pipes provide a network abstraction over the peer
endpoint transport. Peer endpoints correspond to the available peer
network interfaces that can be used to send and receive data from
another peer. Pipes connect one or more peer endpoints. At each
endpoint software to send or receive, as well as to manage associated
pipe message queues or streams, is assumed, but message queues are
optional.</P>
<P><SPAN LANG="en">The pipe endpoints are referred to as input pipes
(receiver) and output pipes (transmitter). Pipe endpoints are
dynamically bound to a peer endpoint at runtime, via the <A HREF="#proto-pbp">Pipe
Binding Protocol</A>. The pipe binding process consists of searching
for and connecting the two or more endpoints of a pipe.</SPAN></P>
<P><SPAN LANG="en">When a message is sent into an output pipe, the
message is sent by the local peer endpoint to the peer endpoint(s)
where the associated input pipe is located. The set of peer endpoints
currently associated with the input pipes is discovered using the
<A HREF="#proto-pbp">Pipe Binding Protocol</A>.</SPAN></P>
<P LANG="en">A pipe offers two modes of communication:</P>
<DL>
	<DT LANG="en">Point to Point 
	</DT><DD LANG="en">
	A point to point pipe connects exactly two pipe endpoints together:
	an input pipe that receives messages sent from an output pipe. No
	reply or acknowledgment operation is supported. Additional
	information in the message payload (like a unique id) may be
	required to thread message sequences. The message payload may also
	contain a pipe advertisement that can be used to open a pipe to
	reply to the sender (send/response). 
	</DD><DT LANG="en">
	Propagate Pipe 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A propagate pipe connects one output pipe and multiple input pipes
	together. Messages flow from the output pipe (propagation source)
	into the input pipes. A propagate message is sent to all listening
	input pipes. This process may create multiple copies of the message
	to be sent. On TCP/IP, when the propagate scope maps an underlying
	physical subnet in a 1-to-1 fashion, IP multicast may be used as an
	implementation for propagate pipes. For transports (such as HTTP)
	that do not provide multicast, propagate pipes can be implemented
	using point-to-point communication. 
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="id286970"></A><B>Figure&nbsp;2.&nbsp;JXTA Pipe Types</B></P>
<P STYLE="margin-bottom: 0cm"><IMG SRC="JXTA_Protocols_2_0_files/pipetype.gif" NAME="graphics1" ALT="Diagram showing both point-to-point pipes and propagate pipes." ALIGN=BOTTOM WIDTH=496 HEIGHT=251 BORDER=0>
</P>
<P><BR><BR>
</P>
<P LANG="en">Pipes may connect two peers that do not have a direct
physical link. In this case, one or more intermediary peer endpoints
are used to route messages between the two pipe endpoints.</P>
<H2 LANG="en" CLASS="title"><A NAME="id287021"></A>3.8.&nbsp;Messages</H2>
<P LANG="en">The information transmitted using pipes and between
endpoints is packaged as messages. Messages define an envelope to
transfer any kind of data. A message may contain an arbitrary number
of named sub-sections which can hold any form of data.</P>
<P LANG="en">It is the intent that the JXTA protocols be compliant
with W3C XML Protocol standards, so that the JXTA protocols can be
implemented on XML transports such as SOAP, XML-RPC, etc.</P>
<P LANG="en">The JXTA protocols are specified as a set of XML
messages exchanged between peers. Each software platform binding
describes how a message is converted to and from a native data
structures such as Java objects or &ldquo;C&rdquo; structures.</P>
<P LANG="en">The use of XML messages to define protocols allows many
different kinds of peers to participate in a protocol. Each peer is
free to implement the protocol in a manner best suited to its
abilities and role.</P>
<H2 LANG="en" CLASS="title"><A NAME="overview-codats"></A>3.9.&nbsp;Codats</H2>
<P><SPAN LANG="en">The JXTA protocols assume that many types of
contents may be shared, exchanged, and replicated between peers. A
content can be a text file, a structured document (like a PDF or an
XML file), a Java </SPAN><CODE><SPAN LANG="en">.jar</SPAN></CODE><SPAN LANG="en">
or loadable library, code or even an executable process. No size
limitation is assumed.</SPAN></P>
<P><SPAN LANG="en">Content are published and shared amongst peer
members of a peer group. When a content is shared within the JXTA
network it is associated with a JXTA ID. The combination of a content
and a JXTA ID is known as a </SPAN><EM><A HREF="#gloss-codat"><SPAN LANG="en">Codat</SPAN></A></EM><SPAN LANG="en">.
A codat may belong to only one peer group. If the same content must
be published in two different peer groups, two different codats are
created. The two codats may, of course, represent the same content.</SPAN></P>
<P LANG="en">Each codat is uniquely identified by a JXTA ID. All
codats make their existence known to peer members by publishing a
content advertisement.</P>
<P LANG="en">A codat instance is a copy of a codat. Each codat copy
may be replicated on different peers in the peer group. Each copy has
the same codat id and an identical content.</P>
<P LANG="en">Replicating codats within a peer group helps to ensure
that each item of content is more readily available. For example, if
an item has two instances residing on two different peers, only one
of the peers needs to be alive to respond to the content request.</P>
<P LANG="en">The JXTA protocols do not specify how codats are
replicated. This decision is left to higher-level content service
managers.</P>
<H1 LANG="en" CLASS="title"><A NAME="core"></A>Part&nbsp;1.&nbsp;JXTA
Core Specification</H1>
<H1 LANG="en" CLASS="title"><A NAME="core-i"></A>Introduction</H1>
<P><SPAN LANG="en">JXTA is designed to be a small system with only a
few required components and behaviours. The functionality that is
required of all implementations is defined by the </SPAN><EM><A HREF="#gloss-jcs"><SPAN LANG="en">JXTA
Core Specification</SPAN></A></EM><SPAN LANG="en"> and is documented
in this section. Implementations that wish to be JXTA compliant must
implement all of the <A HREF="#core">JXTA Core Specification</A>.</SPAN></P>
<P><SPAN LANG="en">Implementation of the <A HREF="#core">JXTA Core
Specification</A> does not guarantee or even necessarily provide
interoperability with other JXTA implementations. There are a number
of types of components and behaviours which need to be provided by
JXTA implementation which are not part of the <A HREF="#core">JXTA
Core Specification</A>. Existing implementations of these components
are described separately in <A HREF="#stdsvc">JXTA Standard Services</A>
and <A HREF="#refimpls">JXTA Reference Implementations Information</A>.
In order for a JXTA implementation to be interoperable with other
implementations it may be necessary to implement some of the
components described there.</SPAN></P>
<P LANG="en"><B>Table of Contents</B></P>
<DL>
	<DT><SPAN LANG="en"><A HREF="#ids">1. IDs</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#ids-i">1.1. Introduction</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-jip">1.2. JXTA ID Properties</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-ujip">1.3. Using JXTA IDs in
		Protocols</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-fjiu">1.4. Format of a JXTA ID URN</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-ejiu">1.5. Example JXTA ID URNs</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id288806">1.6. JXTA ID Representation</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-jif">1.7. JXTA ID Formats</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-jit">1.8. JXTA ID Types</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#ids-jinf">1.9. JXTA ID Formats : &ldquo;jxta&rdquo;
		ID Format</A> </SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#core-advert">2. Advertisements</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#advert-i">2.1. Introduction</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#advert-x">2.2. XML and JXTA
		Advertisements</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#advert-pa">2.3. Peer Advertisement</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#advert-pga">2.4. Peer Group Advertisement</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#advert-mca">2.5. Module Class
		Advertisement</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#advert-msa">2.6. Module Specification
		Advertisement</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#advert-mia">2.7. Module Implementation
		Advertisement</A> </SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#core-proto">3. JXTA Core Protocols</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#proto-prp">3.1. Peer Resolver Protocol</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#proto-erp">3.2. Endpoint Routing Protocol</A>
		</SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#core-trans">4. Core JXTA Message Transport
	Bindings</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#trans-endpt">4.1. Endpoint Service</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#trans-router">4.2. Endpoint Router
		Transport Protocol</A> </SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#msgs">5. Messages</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#id295839">5.1. Introduction</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#id296192">5.2. Message</A> </SPAN>
		</DT><DT STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en"><A HREF="#id296221">5.3. Element</A> </SPAN>
		</DT></DL>
</DL>
<H2 LANG="en" CLASS="title">
<A NAME="ids"></A>Chapter&nbsp;1.&nbsp;IDs</H2>
<H2 LANG="en" CLASS="title"><A NAME="ids-i"></A>1.1.&nbsp;Introduction</H2>
<P LANG="en">The JXTA protocols often need to refer to peers, peer
groups, pipes and other JXTA resources. These references are
presented in the protocols as JXTA IDs. JXTA IDs are a means for
uniquely identifying specific peer groups, peers, pipes, codat and
service instances. JXTA IDs provide unambiguous references to the
various JXTA entities. There are six types of JXTA entities which
have JXTA ID types defined: peergroups, peers, pipes, codats, module
classes and module specifications. Additional JXTA ID types may be
defined in the future.</P>
<P><SPAN LANG="en">JXTA IDs are normally presented as URNs. URNs are
a form of URI that &ldquo;... are intended to serve as persistent,
location-independent, resource identifiers&rdquo;. Like other forms
of URI, JXTA IDs are presented as text. See &ldquo;IETF RFC 2141&rdquo;
<A HREF="#bib-RFC2141">RFC2141</A> for more information on URNs.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="ids-jip"></A>1.2.&nbsp;JXTA ID
Properties</H2>
<P LANG="en">Every JXTA ID, regardless of format or type has the
following properties:</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Unambiguous. It must be
	a complete reference to the resource. 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Relatively Unique. A
	JXTA ID must refer to a single resource. 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Canonical. References to
	the same resource should encode to the same JXTA ID. This enables
	JXTA IDs to be compared to determine if they refer to the same
	resource, but understandably may not be achievable by all ID
	Formats. 
	</P>
	<LI><P LANG="en">Opaque. In their URN presentation JXTA IDs should
	be assumed to be opaque. The context of an ID within a protocol
	message generally is sufficient to establish its type. A JXTA
	binding may be able to interpret an ID if it supports the ID Format.
	Generally, only the immediate participants in a JXTA protocol need
	to understand the contents of a JXTA ID, if at all. 
	</P>
</UL>
<H2 LANG="en" CLASS="title"><A NAME="ids-ujip"></A>1.3.&nbsp;Using
JXTA IDs in Protocols</H2>
<P><SPAN LANG="en">When JXTA IDs are used within protocols they are
manipulated as text string URIs. There are three operations available
for URIs; compare, resolve, decompose. JXTA ID URIs are comparable
for equality as strings. JXTA ID URIs can also be resolved to the
resource they reference. Finally, JXTA ID URIs can optionally be
decomposed and interpreted by JXTA bindings. In order to interpret a
JXTA ID, a JXTA binding must support the </SPAN><EM><A HREF="#gloss-idformat"><SPAN LANG="en">JXTA
ID Format</SPAN></A></EM><SPAN LANG="en"> used by that JXTA ID. For
many JXTA protocols and operations it is not necessary to decompose
the JXTA IDs.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="ids-fjiu"></A>1.4.&nbsp;Format
of a JXTA ID URN</H2>
<P><SPAN LANG="en">A JXTA ID is a standard URN in the JXTA ID
namespace. JXTA ID URNs are identified by the URN namespace
identifier </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">.
Each JXTA ID URN also contains a JXTA ID Format keyword. The ID
Format keyword indicates how the ID was created and may also allow
JXTA bindings to extract additional information from the ID.</SPAN></P>
<P><SPAN LANG="en">Two ID formats have been defined which are
identified by the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
and </SPAN><CODE><SPAN LANG="en">uuid</SPAN></CODE><SPAN LANG="en">
keywords. It is possible to define additional JXTA ID Formats in
order to refer to resources both within JXTA and to bridge to other
technologies.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="ids-ejiu"></A>1.5.&nbsp;Example
JXTA ID URNs</H2>
<P LANG="en">The following examples demonstrate valid JXTA ID
presentation forms. These examples are not necessarily valid JXTA
IDs.</P>
<P LANG="en" CLASS="title"><A NAME="ids-e"></A><B>Example&nbsp;1.1.&nbsp;Sample
JXTA IDs</B></P>
<PRE LANG="en" CLASS="programlisting">A.  urn:jxta:idform-1234567890
<SPAN LANG="en">B.  URN:jxta:idform-1234567890</SPAN>
<SPAN LANG="en">C.  urn:JXTA:idform-1234567890</SPAN>
<SPAN LANG="en">D.  urn:JXTA:IDForm-1234567890</SPAN>
<SPAN LANG="en">E.  urn:jxta:idform2-ABCDEFG</SPAN>
<SPAN LANG="en">F.  urn:jxta:idform3-31:08:66:42:67:::91:24::73</SPAN></PRE><P>
<BR><BR>
</P>
<P><SPAN LANG="en">In the preceding examples, A., B. and C. represent
the same JXTA ID. Both the </SPAN><CODE><SPAN LANG="en">URN</SPAN></CODE><SPAN LANG="en">
portion and the </SPAN><CODE><SPAN LANG="en">JXTA</SPAN></CODE><SPAN LANG="en">
are case insensitive. Example D. is not equivalent to any of A., B.
or C. because the data portion of the URN is case sensitive. In the
six examples, four different JXTA ID Formats are used: &ldquo;idform&rdquo;,
&ldquo;IDForm&rdquo;, &ldquo;idform2&rdquo; and &ldquo;idform3&rdquo;.
Definition of ID Format names that differ only in character case is
not recommended. The interpretation of the characters following the
&ldquo;-&rdquo; is specific to each ID Format.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="id288806"></A>1.6.&nbsp;JXTA ID
Representation</H2>
<P><SPAN LANG="en">JXTA IDs are presented as URNs of the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace. The JXTA ID Namespace specifies additional restrictions
upon the format of the URN. These requriements are detailed in <A HREF="#ids-fjia">JXTA
ID ABNF</A>. The following figure uses the ABNF syntax as defined in
&ldquo;IETF RFC 2234&rdquo; <A HREF="#bib-RFC2234">RFC2234</A>.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="ids-fjia"></A><B>Figure&nbsp;1.1.&nbsp;JXTA
ID ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;JXTAURN&gt;    ::= &quot;urn:&quot; &lt;JXTANS&gt; &quot;:&quot; &lt;JXTAIDVAL&gt;

<SPAN LANG="en">&lt;JXTANS&gt;     ::= &quot;jxta&quot;</SPAN>

<SPAN LANG="en">&lt;JXTAIDVAL&gt;  ::= &lt;JXTAFMT&gt; &quot;-&quot; &lt;JXTAIDUNIQ&gt;</SPAN>

<SPAN LANG="en">&lt;JXTAFMT&gt;    ::= 1 * &lt;URN chars&gt;</SPAN>

<SPAN LANG="en">&lt;JXTAIDUNIQ&gt; ::= 1 * &lt;URN chars&gt;</SPAN>

<SPAN LANG="en">&lt;URN chars&gt;  ::= &lt;trans&gt; | &quot;%&quot; &lt;hex&gt; &lt;hex&gt;</SPAN>

<SPAN LANG="en">&lt;trans&gt;      ::= &lt;upper&gt; | &lt;lower&gt; | &lt;number&gt; | &lt;other&gt; |</SPAN>
                 <SPAN LANG="en">&lt;reserved&gt;</SPAN>

<SPAN LANG="en">&lt;upper&gt;      ::= &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; |</SPAN>
                 <SPAN LANG="en">&quot;I&quot; | &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; |</SPAN>
                 <SPAN LANG="en">&quot;Q&quot; | &quot;R&quot; | &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; |</SPAN>
                 <SPAN LANG="en">&quot;Y&quot; | &quot;Z&quot;</SPAN>

<SPAN LANG="en">&lt;lower&gt;      ::= &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; |</SPAN>
                 <SPAN LANG="en">&quot;i&quot; | &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; |</SPAN>
                 <SPAN LANG="en">&quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; |</SPAN>
                 <SPAN LANG="en">&quot;y&quot; | &quot;z&quot;</SPAN>

<SPAN LANG="en">&lt;hex&gt;        ::= &lt;number&gt; | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |</SPAN>
                 <SPAN LANG="en">&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;</SPAN>

<SPAN LANG="en">&lt;number&gt;     ::= &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |</SPAN>
                 <SPAN LANG="en">&quot;8&quot; | &quot;9&quot;</SPAN>

<SPAN LANG="en">&lt;other&gt;      ::= &quot;(&quot; | &quot;)&quot; | &quot;+&quot; | &quot;,&quot; | &quot;-&quot; | &quot;.&quot; |</SPAN>
                 <SPAN LANG="en">&quot;:&quot; | &quot;=&quot; | &quot;@&quot; | &quot;;&quot; | &quot;$&quot; |</SPAN>
                 <SPAN LANG="en">&quot;_&quot; | &quot;!&quot; | &quot;*&quot; | &quot;'&quot;</SPAN>

<SPAN LANG="en">&lt;reserved&gt;   ::= &quot;%&quot; | &quot;/&quot; | &quot;?&quot; | &quot;#&quot;</SPAN></PRE><P>
<BR><BR>
</P>
<P><SPAN LANG="en">The jxta URN namespace does not currently define
any special symbols from the </SPAN><CODE><SPAN LANG="en">reserved</SPAN></CODE><SPAN LANG="en">
set.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="ids-jif"></A>1.7.&nbsp;JXTA ID
Formats</H2>
<P><SPAN LANG="en">JXTA IDs are designed to support multiple ID
Formats. ID Formats allow JXTA developers to utilize existing naming
and ID schemes within JXTA. In the JXTA ID presentation, the ID's
&ldquo;Format&rdquo; follows the JXTA URN namespace. Any JXTA ID
Format which follows the general requirements for URNs and the <A HREF="#ids-jip">JXTA
ID Properties</A> will be usable by conformant JXTA implementations.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="ids-jit"></A>1.8.&nbsp;JXTA ID
Types</H2>
<P LANG="en">JXTA IDs may refer to many types of resources; pipes,
peers, etc. Each JXTA ID format type may support references to one or
more of these resource types. Currently, five standard resource types
have been identified; peer groups, peers, pipes, content and service
instances. Other types may be defined.</P>
<P LANG="en">Each of the individual ID Types may provide additional
requirements specific to its type.</P>
<H3 LANG="en" CLASS="title"><A NAME="ids-jit-pgi"></A>1.8.1.&nbsp;Peer
Group IDs</H3>
<P LANG="en">Peer Group IDs refer to peer groups. A peer group ID
should canonically, uniquely and unambiguously refer to a peer group.
Every ID Format must support this ID Type because all of the other ID
Types refer to the peer group to which they belong. Every ID Format
must support encoding of the World Peer Group. Support for other peer
groups is optional. Example: You are defining an ID Format for Peer
IDs based upon driver's license number. Driver's licenses are not
organized into groups. This can be considered equivalent to all
driver's licenses belonging to the same group, the global &ldquo;world
peer group&rdquo;.</P>
<H3 LANG="en" CLASS="title"><A NAME="ids-jit-pei"></A>1.8.2.&nbsp;Peer
IDs</H3>
<P LANG="en">Peer IDs refer to peers. A Peer ID should canonically,
uniquely and anambiguously refer to a peer. Support for this ID Type
is optional. If a JXTA binding recognizes the ID Format, it should be
able to determine the assocaiated Peer Group ID from a Peer ID. This
Peer Group ID identifies the peer group of which the peer is a
member.</P>
<H3 LANG="en" CLASS="title"><A NAME="ids-jit-ci"></A>1.8.3.&nbsp;Codat
IDs</H3>
<P LANG="en">Codat IDs refer to codats. A Codat ID should
canonically, uniquely and anambiguously refer to a codat. Support for
this ID Type is optional. If a JXTA binding recognizes the ID Format,
it should be able to determine the assocaiated Peer Group ID from a
Codat ID. This Peer Group ID identifies the peer group of which the
codat is a member.</P>
<H3 LANG="en" CLASS="title"><A NAME="ids-jit-pii"></A>1.8.4.&nbsp;Pipe
IDs</H3>
<P LANG="en">Pipe IDs refer to pipes. A Pipe ID should canonically,
uniquely and anambiguously refer to a pipe. Support for this ID Type
is optional. If a JXTA binding recognizes the ID Format, it should be
able to determine the assocaiated Peer Group ID from a Pipe ID. This
Peer Group ID identifies the peer group of which the pipe is a
member.</P>
<H3 LANG="en" CLASS="title"><A NAME="ids-jit-mci"></A>1.8.5.&nbsp;Module
Class IDs</H3>
<P LANG="en">A Module Class ID identifies a particular local
behavior, that is, a specific API for each execution environment for
which an implementation exists. A Module Class ID should canonically,
uniquely and unambiguously refer to a module class as defined by an
advertisement. Support for this ID Type is optional. If a JXTA
binding recognizes the ID Type, it should be able to extract a Base
Class ID from a Module Class ID. The Base Class ID allows
applications to determine if two Module Class IDs differ only in the
&ldquo;role&rdquo; they perform. Module Spec ID's &ldquo;roles&rdquo;
allow for the same module to be reused within a group and have
instances distinguished. This is necessary when, for example, a
common database service is used, with each &ldquo;role&rdquo;
accessing a different data set.</P>
<H3 LANG="en" CLASS="title"><A NAME="ids-jit-msi"></A>1.8.6.&nbsp;Module
Spec IDs</H3>
<P LANG="en">A ModuleSpecID uniquely identifies a particular network
behavior (wire protocol and choreography) that may be embodied by a
Jxta Module. There may be any number of implementations of a given
Module Spec ID. A ModuleSpecID uniquely identifies an abstract module
for which there may be multiple platform specific implementations. A
ModuleSpecID is used to locate a compatible implementation such that
it can be instantiated. All such implementations are assumed to be
network compatible. A Module Spec ID should canonically, uniquely and
unambiguously refer to a module specification. Support for this ID
Type is optional. If a JXTA binding recognizes the ID Type, it should
be able to extract a Module Class ID from a Module Spec ID.</P>
<H2 LANG="en" CLASS="title"><A NAME="ids-jinf"></A>1.9.&nbsp;JXTA ID
Formats : &ldquo;jxta&rdquo; ID Format</H2>
<P LANG="en">The &ldquo;jxta&rdquo; ID Format is a required ID Format
that is used for encoding &ldquo;well known&rdquo; JXTA identifiers.
All JXTA binding implementations must support this ID Format. There
are three special reserved JXTA IDs; the Null ID, the World Peer
Group ID and the Net Peer Group ID. The &ldquo;jxta&rdquo; ID Format
exists so that for these few &ldquo;well known&rdquo; IDs only a
single representation exists.</P>
<P LANG="en" CLASS="title"><A NAME="ids-fjifa"></A><B>Figure&nbsp;1.2.&nbsp;JXTA
ID : &quot;jxta&quot; ID Format ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;JXTAJXTAURN&gt;    ::= &quot;urn:&quot; &lt;JXTANS&gt; &quot;:&quot; &lt;JXTAJXTAFMT&gt; &quot;-&quot;
                     <SPAN LANG="en">&lt;JXTAJXTAFMTID&gt;</SPAN>

<SPAN LANG="en">&lt;JXTAJXTAFMT&gt;    ::= &quot;jxta&quot;</SPAN>

<SPAN LANG="en">&lt;JXTAJXTAFMTID&gt;  ::= &lt;JXTANULL&gt; | &lt;JXTAWORLDGROUP&gt; | &lt;JXTANETGROUP&gt;</SPAN>

<SPAN LANG="en">&lt;JXTANULL&gt;       ::= &quot;Null&quot;</SPAN>

<SPAN LANG="en">&lt;JXTAWORLDGROUP&gt; ::= &quot;WorldGroup&quot;</SPAN>

<SPAN LANG="en">&lt;JXTANETGROUP&gt;   ::= &quot;NetGroup&quot;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H2 LANG="en" CLASS="title"><A NAME="core-advert"></A>Chapter&nbsp;2.&nbsp;Advertisements</H2>
<H2 LANG="en" CLASS="title"><A NAME="advert-i"></A>2.1.&nbsp;Introduction</H2>
<P LANG="en">Advertisements are meta-data documents used by JXTA
protocols to describe resources. Advertisements are used to describe
peers, peer groups, pipes, content, services and many other types of
resources. JXTA Advertisements are presented in XML. Many of the JXTA
protocols depend on Advertisements to provide necessary information.
JXTA protocols are used to pass Advertisements between peers.</P>
<P LANG="en">Services can define new Advertisement types by
sub-typing existing Advertisement types or by defining completely new
Advertisements. Advertisement sub-types allow for additional
information to be provided as well as richer meta-data.</P>
<P LANG="en">Advertisements are composed of a series of
hierarchically arranged elements. The elements may appear in any
order within the advertisement. Each element can contain its data or
additional elements. An element can also have attributes. Attributes
are name-value string pairs. An attribute is used to store meta-data,
which helps to describe the data within the element.</P>
<P LANG="en">The Core JXTA Protocols rely on the following
advertisements:</P>
<UL TYPE=DISC>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#advert-pa">Peer
	Advertisement</A> </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#advert-pga">Peer
	Group Advertisement</A> </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#advert-mca">Module
	Class Advertisement</A> </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><SPAN LANG="en"><A HREF="#advert-msa">Module
	Specification Advertisement</A> </SPAN>
	</P>
	<LI><P><SPAN LANG="en"><A HREF="#advert-mia">Module Implementation
	Advertisement</A> </SPAN>
	</P>
</UL>
<H2 LANG="en" CLASS="title"><A NAME="advert-x"></A>2.2.&nbsp;XML and
JXTA Advertisements</H2>
<P LANG="en">All JXTA advertisements are represented in XML. XML
provides a powerful means of representing data and metadata
throughout a distributed system. XML provides a universal
(software-platform neutral) representation:</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">XML is programming
	language agnostic 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">XML is self-describing 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">XML content can be
	strongly-typed 
	</P>
	<LI><P LANG="en">XML ensures correct syntax 
	</P>
</UL>
<P><SPAN LANG="en">These advantages allow peers to manage and use
Advertisements safely and to be able to ensure correct interactions
with other peers. The Advertisements defined by the </SPAN><EM><SPAN LANG="en">JXTA
Core Specification</SPAN></EM><SPAN LANG="en">and the </SPAN><EM><SPAN LANG="en">JXTA
Standard Services</SPAN></EM><SPAN LANG="en">are specified using the
</SPAN><EM><SPAN LANG="en">XML Schema Definition Language</SPAN></EM><SPAN LANG="en">
<A HREF="#bib-XSD2001-1">XSD2001-1</A> <A HREF="#bib-XSD2001-2">XSD2001-2</A>.
Use of XML Schemas allows the advertisement contents to be strongly
type-checked and semanticly validated beyond the syntactical
validation provided by XML with DTDs. Service and protocol authors
are recommendedto specify their Advertisements or Advertisement
sub-types using XML Schema Language. DTDs are normally prepared from
the schema descriptions for use in environments which do not support
XML schema.</SPAN></P>
<P LANG="en">The other powerful feature of XML is its ability to be
translated into other encodings such as HTML and WML. This feature
allows peers that do not support XML to access advertised resources.</P>
<P LANG="en" CLASS="title"><A NAME="fpcafs"></A><B>Figure&nbsp;2.1.&nbsp;Common
Advertisement Fragments Schemas</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:simpleType name=&quot;JXTAID&quot;&gt;
 <SPAN LANG="en">&lt;xs:restriction base=&quot;xs:anyURI&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:pattern value=&quot;([uU][rR][nN]:[jJ][xX][tT][aA]:).+\-.+&quot;/&gt;</SPAN>
 <SPAN LANG="en">&lt;/xs:restriction&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:simpleType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;serviceParam&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MCID&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Parm&quot; type=&quot;xs:anyType&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;Cred&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:all&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:all&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>
      </PRE><P LANG="en">
<BR><BR>
</P>
<H2 LANG="en" CLASS="title"><A NAME="advert-pa"></A>2.3.&nbsp;Peer
Advertisement</H2>
<P LANG="en">A Peer Advertisement describes a peer and the resources
it provides to the group. The Peer Advertisement holds specific
information about the peer such as its its unique id, its group id
and optionally its name and descriptive information. It may also
contain endpoint addresses and any run-time attributes that
individual peer services want to publish (such as being a rendezvous
peer for a group).</P>
<P LANG="en" CLASS="title"><A NAME="fpas"></A><B>Figure&nbsp;2.2.&nbsp;Peer
Advertisement Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">PA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:PA&quot;/&gt;</SPAN>
 <SPAN LANG="en">&lt;xs:complexType name=&quot;PA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
   <SPAN LANG="en">&lt;xs:element name=&quot;PID&quot; type=&quot;JXTAID&quot;/&gt;</SPAN>
   <SPAN LANG="en">&lt;xs:element name=&quot;GID&quot; type=&quot;JXTAID&quot;/&gt;</SPAN>
   <SPAN LANG="en">&lt;xs:element name=&quot;Name&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
   <SPAN LANG="en">&lt;xs:element name=&quot;Desc&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
   <SPAN LANG="en">&lt;xs:element name=&quot;Svc&quot; type=&quot;jxta:serviceParams&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;PID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is a required element that uniquely identifies this peer. Each
	peer has a unique id. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;GID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is a required element that identifies the Peer Group to which
	this peer belongs. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Name&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional string that can be associated with a peer. The
	name is not required to be unique unless the name is obtained from a
	centralized naming service that guarantees name uniqueness. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Desc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional string that can be used to index and search for
	a peer. The string is not guaranteed to be unique. Two peers may
	have the same keywords. The keywords string may contain spaces. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Svc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Any number of such elements may exist. Each of them describes the
	association between a group service denoted by its Class ID (the
	value of an MCID element), and arbitrary parameters encapsulated in
	a Parm element. For example, all accessible endpoint addresses are
	published in association with the Endpoint Service Class ID. The TLS
	Root certificate is published under the PeerGroup Class ID (There is
	a class ID for Peer Group as well). The flag that denotes that this
	peer is a rendezvous for this group is published under the
	Rendezvous Service Class ID. Ultimately, each service is responsible
	for what is published under its Class ID. The Service section may
	also optionally contain an element &quot;isOff&quot; meaning that
	this service is disabled. This element is used to convey a
	configuration choice made by the owner of the peer. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="advert-pga"></A>2.4.&nbsp;Peer Group Advertisement</H2>
<P LANG="en">A Peer Group Advertisement describes peergroup specific
resources: name, group id, description, specification, and service
parameters.</P>
<P LANG="en" CLASS="title"><A NAME="fpgas"></A><B>Figure&nbsp;2.3.&nbsp;Peer
Group Advertisement Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">PGA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:PGA&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;PGA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;GID&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MSID&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Name&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Desc&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Svc&quot; type=&quot;jxta:serviceParam&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;GID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">This element provides the Peer Group ID. The Peer
	Group ID is the canonical way of refering to a group and uniquely
	identifies the peer group. See <A HREF="#ids-jit-pgi">Peer Group
	IDs</A>for more information on peer group ids. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;MSID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Peer group Specification ID. This designates the module that
	provides the peer group mechanism itself for that group. The spec ID
	designates an abstraction of that mechanism. This abstraction is
	optionally described by a ModuleSpecAdvertisement, and any number of
	implementations may exist, each described by a
	ModuleImplAdvertisement. These advertisements may all be searched by
	this SpecID. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Name&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional name that can be associated with a peergroup.
	The name is not required to be unique unless the name is obtained
	from a centralized naming service that guarantee name uniqueness. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Desc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional element provides descriptive information that
	may be used to index and search for a peergroup. The content of this
	element may not be unique. For example, two peergroups may have the
	same keywords. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Svc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Any number of such elements may exist. Each of them describes the
	association between a group service denoted by its Class ID (the
	value of an MCID element), and arbitrary parameters encapsulated in
	a Parm element. This optional parameter may only be meaningful to
	some services. It is used to configure a service specifically in
	relation with its use by this group. For example, a simple
	membership service may find an encrypted password list there. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="advert-mca"></A>2.5.&nbsp;Module Class Advertisement</H2>
<P LANG="en">A Module Class Advertisement describes a class of
modules. That is, an expected local behavior and the expected API for
each JXTA binding (that supports such modules). The purpose of this
advertisement is to provide a description of what a particular Module
Class ID stands for. A Module Class ID is what other modules or other
code running on JXTA uses to designate modules which it depends upon.
The ModuleClassAdvertisement is not required to provide a completely
formal description of the module's behavior and API. It is intended
for humans who want to create modules with a similar functionality.
It is not required to publish a Module Class Advertisement for a
Module Class ID to be valid, although it is a good practice.</P>
<P LANG="en" CLASS="title"><A NAME="fmcas"></A><B>Figure&nbsp;2.4.&nbsp;Module
Class Advertisement Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">MCA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:MCA&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;MCA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MCID&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Name&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/?</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Desc&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;MCID&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	Module Class ID. This is a required element that uniquely identifies
	the class. Each module class has a unique id. The class id
	representation is given in the Id Chapter. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Name&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional name that can be associated with a class. The
	name is not required to be unique unless the name is obtained from a
	centralized naming service that guarantee name uniqueness. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Desc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Description. This is an optional string that can be used to describe
	and search for a class. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="advert-msa"></A>2.6.&nbsp;Module Specification Advertisement</H2>
<P LANG="en">A Module Specification Advertisement describes the
specification of a module. That is, an expected on-wire behavior and
protocol. The purpose of this advertisement is to provide a
description of what a particular Module Specification ID stands for.
A Module Specification ID is what other modules or other code running
on JXTA uses to designate a particular network-compatible family of
implementations of a given class. It is more importantly how a group
implementation may designate the components which provide the various
services that this group supports. All the built-in core peergroup
services (discovery, membership, resolver,...) are modules.</P>
<P LANG="en">It is not required to publish a Module Spec
Advertisement for a Module Spec ID to be valid, although it is a good
practice.</P>
<P LANG="en">A Module Spec Advertisement may also describe how to
invoke and use a module. A Module may be used through its API, by
locating an implementation, loading it and starting it, or a module
may be usable through a pipe or through a proxy module. Modules which
permit this include one or both of a Pipe Advertisement or the Module
Spec ID of a proxy module, in their ModuleSpecID. Publication of the
Module Spec Advertisement is of course required in that case.</P>
<P LANG="en">A Module Specification Advertisement is not required to
provide a completely formal description of the module's network
behavior or protocol, it is intended for humans who want to create
compatible implementation of that specification.</P>
<P LANG="en" CLASS="title"><A NAME="fmsas"></A><B>Figure&nbsp;2.5.&nbsp;Module
Specification Advertisement Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">MSA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:MSA&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;MSA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MSID&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Vers&quot; type=&quot;xs:string&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Name&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Desc&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Crtr&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;SURI&quot; type=&quot;xs:anyURI&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Parm&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:PipeAdvertisement&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Proxy&quot; type=&quot;xs:anyURI&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Auth&quot; type=&quot;jxta:JXTAID&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;MSID&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	ModuleSpecID. This is a required element that uniquely identifies
	the specification. Each module specification has a unique id. The
	spec id representation is given in the Id Chapter. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Vers&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The mandatory version of the specification that this advertises. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Name&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional name that can be associated with a spec. The
	name is not required to be unique unless the name is obtained from a
	centralized naming service that guarantee name uniqueness. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Desc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Description. This is an optional string that can be used to describe
	and search for a spec. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;CRTR&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Creator. This optional element designates the creator of this
	specification. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;SURI&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Spec URI. This optional element is a URI that permits to retrieve a
	document containing the specification that this advertises. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Parm&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Arbitrary parameters to be interpreted by each implementation. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;jxta:PipeAdvertisement&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	Pipe advertisement. A pipe advertisement which this module binds to
	an input pipe and which thus may be used to establish a pipe to a
	nearby running implementation of this specification. Note that the
	element name is identical to the Pipe Advertisement document type
	since the entire element is an embedded pipe advertisement document.
		</DD><DT>
	<CODE><SPAN LANG="en">&lt;Proxy&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Proxy Spec ID. Optional ModuleSpecID of a proxy module that may be
	used in order to communicate with modules of this specification.
	Note that the process may be recursive. The proxy module may be
	usable via pipes, or through a subsequent proxy module, and itself
	require a subsequent authenticator. However publishers of modules
	should probably avoid such designs. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Auth&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Authenticator Spec ID. Optional ModuleSpecID of an authenticator
	module that may be required in order to communicate with modules of
	this specification. Note that the process may be recursive. The
	authenticator module may be usable via pipes, or through a
	subsequent proxy module, and itself require a subsequent
	authenticator. However publishers of modules should probably avoid
	such designs. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="advert-mia"></A>2.7.&nbsp;Module Implementation
Advertisement</H2>
<P LANG="en">A Module Implementation Advertisement describes one of
the implementations of a module specification. Implementations of a
given specification may be searched by the SpecID. An implementation
may be selected by the type of environment in which it can be used
(its compatibility statement) as well as by its name, description or
the content of its parameters section.</P>
<P><SPAN LANG="en">A Module Implementation Advertisement also
provides a means to retrieve all the necessary data required in order
to execute the implementation being described. This information is
encapsulated in the Code and PURI elements. The interpretation of
these elements are subject to the the module's compatibility. For
example, the standard peer group implementation of the Java reference
implementation expects the </SPAN><CODE><SPAN LANG="en">&lt;Code&gt;</SPAN></CODE><SPAN LANG="en">element
to specify a fully qualified Java class name that designates a
subclass of </SPAN><CODE><SPAN LANG="en">net.jxta.platform.Module</SPAN></CODE><SPAN LANG="en">and
PURI to be the URI of a downloadable package (a </SPAN><CODE><SPAN LANG="en">.jar</SPAN></CODE><SPAN LANG="en">file).
Other execution environments could expect the code to be inline
within the </SPAN><CODE><SPAN LANG="en">&lt;Code&gt;</SPAN></CODE><SPAN LANG="en">element
or even offer several options.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="fmias"></A><B>Figure&nbsp;2.6.&nbsp;Module
Implementation Advertisement Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">MIA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:MIA&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;MIA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MSID&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Comp&quot; type=&quot;xs:anyType&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Code&quot; type=&quot;xs:anyType&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PURI&quot; type=&quot;xs:anyURI&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Prov&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Desc&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Parm&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;MSID&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	ModuleSpecID. This is a required element that uniquely identifies
	the specification being implemented. The SpecID representation is
	given in the Id Chapter. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Comp&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Compatibility. A mandatory arbitrary element that describes the
	environment in with this implementation may be executed. Each
	framework capable of loading and executing module has its own
	requirement on the contents of this element. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Code&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This arbitrary element contains anything that is needed in addition
	to the package in order to load and execute the code of this
	implementation. In the case of a java implementation it contains the
	fully qualified class name containing the module's entry points. In
	other cases it may contain the entire code. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;PURI&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Package URI. This optional element is a URI that permits to retrieve
	a package containing the code of this implementation. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Prov&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Provider. The provider of that implementation. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Desc&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Description. This is an optional string that can be used to describe
	and search for a spec. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Parm&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Parameter. Arbitrary parameters to be interpreted by the
	implementation's code. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="core-proto"></A>Chapter&nbsp;3.&nbsp;JXTA Core Protocols</H2>
<H2 LANG="en" CLASS="title"><A NAME="proto-prp"></A>3.1.&nbsp;Peer
Resolver Protocol</H2>
<H3 LANG="en" CLASS="title"><A NAME="proto-prp-intro"></A>3.1.1.&nbsp;Introduction</H3>
<P><SPAN LANG="en">The </SPAN><EM><A HREF="#gloss-prp"><SPAN LANG="en">Peer
Resolver Protocol</SPAN></A></EM><SPAN LANG="en"> (</SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">)
provides a generic query/response interface applications and services
can use for building resolution services. The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
provides the ability to issue queries within a peer group and later
identifying matching responses. Each query or response is addressed
to a specific named handler. The Resolver Service of each peer group
cooperates with the named handlers to provide the query routing
strategies and policies. The named handlers provide the specific
semantics for how the query is distributed and resolved within the
peer group and how responses to the query are handled. In most
situations the service or application has the best knowledge of the
group topology and how the query should be routed. A query may be
received and processed by any number of peers withinin the peer
group, possibly all, and it is processed accordingly by a handler if
such a named handler is registered on that peer.</SPAN></P>
<P><SPAN LANG="en">Peers may also participate in the Shared Resource
Distributed Index (</SPAN><SPAN LANG="en">SRDI</SPAN><SPAN LANG="en">).
</SPAN><SPAN LANG="en">SRDI</SPAN><SPAN LANG="en"> provides a generic
mechanism JXTA services and applications can utilize a distributed
index of shared resources with other peers that are grouped as a set
of more capable peers such as rendezvous peers. These indices can be
used to direct queries in the direction where the query is most
likely to be answered, and repropagate messages to peers interested
in these propagated messages.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="proto-prp-rqm"></A>3.1.2.&nbsp;Resolver
Query Message</H3>
<P LANG="en">The resolver query message is used to send a resolver
query to the named handler on one or more peers that are members of
the peer group. The resolver query is sent as a query string to a
specific handler. Each query has a unique Id. The query string can be
any string that will be interpreted by the targeted handler.</P>
<P LANG="en" CLASS="title"><A NAME="frqs"></A><B>Figure&nbsp;3.1.&nbsp;Resolver
Query Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">ResolverQuery</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:ResolverQuery&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;ResolverQuery&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:Cred&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;SrcPeerID&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- This could be extended with a pattern restriction --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;HandlerName&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;QueryID&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;HC&quot; type=&quot;xs:unsignedInt&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- For historical reasons the query is a whole flattened document --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Query&quot; type=&quot;xs:anyType&quot; /&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;jxta:Cred&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The credential of the sender. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;HandlerName&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	A string that specifies the destination of this query. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;SrcPeerID&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The id of the peer originating the query (as a URN). 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;QueryID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">An opaque indentifier to be used by the querier to
	match replies. The </SPAN><CODE><SPAN LANG="en">&lt;QueryID&gt;</SPAN></CODE><SPAN LANG="en">
	should be included in the responses to this query. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;HC&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">specifies the number of hops the query has been
	through The </SPAN><CODE><SPAN LANG="en">&lt;HC&gt;</SPAN></CODE><SPAN LANG="en">
	should be incremented by each peer that fowards the query. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Query&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Contains the query. 
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="frqe"></A><B>Example&nbsp;3.1.&nbsp;Resolver Query</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;

<SPAN LANG="en">&lt;!DOCTYPE jxta:ResolverQuery&gt;</SPAN>

<SPAN LANG="en">&lt;jxta:ResolverQuery xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;HandlerName&gt;</SPAN>
        <SPAN LANG="en">urn:jxta:uuid-DEADBEEFDEAFBABAFEEDBABE0000000305</SPAN>
    <SPAN LANG="en">&lt;/HandlerName&gt;</SPAN>
    <SPAN LANG="en">&lt;jxta:Cred&gt;</SPAN>
        <SPAN LANG="en">JXTACRED</SPAN>
    <SPAN LANG="en">&lt;/jxta:Cred&gt;</SPAN>
    <SPAN LANG="en">&lt;QueryID&gt;</SPAN>
        <SPAN LANG="en">0</SPAN>
    <SPAN LANG="en">&lt;/QueryID&gt;</SPAN>
    <SPAN LANG="en">&lt;HC&gt;</SPAN>
        <SPAN LANG="en">0</SPAN>
    <SPAN LANG="en">&lt;/HC&gt;</SPAN>
    <SPAN LANG="en">&lt;SrcPeerID&gt;</SPAN>
        <SPAN LANG="en">urn:jxta:uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503</SPAN>
    <SPAN LANG="en">&lt;/SrcPeerID&gt;</SPAN>
    <SPAN LANG="en">&lt;Query&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:DiscoveryQuery&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;jxta:DiscoveryQuery xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Type&gt;</SPAN>
                <SPAN LANG="en">0</SPAN>
            <SPAN LANG="en">&amp;lt;/Type&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Threshold&gt;</SPAN>
                <SPAN LANG="en">50</SPAN>
            <SPAN LANG="en">&amp;lt;/Threshold&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;PeerAdv&gt;</SPAN>
                <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

                <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:PA&gt;</SPAN>
                    <EM><SPAN LANG="en">... remainder omitted for brevity ...</SPAN></EM>
                <SPAN LANG="en">&amp;lt;/jxta:PA&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;/PeerAdv&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Attr&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;/Attr&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Value&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;/Value&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;/jxta:DiscoveryQuery&gt;</SPAN>
    <SPAN LANG="en">&lt;/Query&gt;</SPAN>
<SPAN LANG="en">&lt;/jxta:ResolverQuery&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-prp-rrm"></A>3.1.3.&nbsp;Resolver
Response Message</H3>
<P LANG="en">A resolver response message is used to send a response
to a resolver query message.</P>
<P LANG="en" CLASS="title"><A NAME="frrs"></A><B>Figure&nbsp;3.2.&nbsp;Resolver
Response Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">ResolverResponse</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;ResolverResponse&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;ResolverResponse&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:Cred&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;ResPeerID&quot; type=&quot;jxta:JXTAID&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;HandlerName&quot; type=&quot;xs:string&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;QueryID&quot; type=&quot;xs:string&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- For historical reasons the response is a whole flattened document --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Response&quot; type=&quot;xs:anyType&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;jxta:Cred&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The credential of the respondent. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;HandlerName&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	Specifies how to handle the response. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;ResPeerID&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The id of the peer originating the response (as a URN). 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;QueryID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The query identifier of the query to which this is a response. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Response&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The responses. 
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="frre"></A><B>Example&nbsp;3.2.&nbsp;Resolver Response</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;

<SPAN LANG="en">&lt;!DOCTYPE jxta:ResolverResponse&gt;</SPAN>

<SPAN LANG="en">&lt;jxta:ResolverResponse xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;HandlerName&gt;</SPAN>
        <SPAN LANG="en">urn:jxta:uuid-DEADBEEFDEAFBABAFEEDBABE0000000305</SPAN>
    <SPAN LANG="en">&lt;/HandlerName&gt;</SPAN>
    <SPAN LANG="en">&lt;jxta:Cred&gt;</SPAN>
        <SPAN LANG="en">JXTACRED</SPAN>
    <SPAN LANG="en">&lt;/jxta:Cred&gt;</SPAN>
    <SPAN LANG="en">&lt;QueryID&gt;</SPAN>
        <SPAN LANG="en">0</SPAN>
    <SPAN LANG="en">&lt;/QueryID&gt;</SPAN>
    <SPAN LANG="en">&lt;ResPeerID&gt;</SPAN>
        <SPAN LANG="en">urn:jxta:uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503</SPAN>
    <SPAN LANG="en">&lt;/ResPeerID&gt;</SPAN>
    <SPAN LANG="en">&lt;Response&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:DiscoveryResponse&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;jxta:DiscoveryResponse xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Count&gt;</SPAN>
                <SPAN LANG="en">1</SPAN>
            <SPAN LANG="en">&amp;lt;/Count&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Type&gt;</SPAN>
                <SPAN LANG="en">2</SPAN>
            <SPAN LANG="en">&amp;lt;/Type&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;PeerAdv&gt;</SPAN>
                <SPAN LANG="en">&amp;amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

                <SPAN LANG="en">&amp;amp;lt;!DOCTYPE jxta:PA&gt;</SPAN>

                <SPAN LANG="en">&amp;amp;lt;jxta:PA xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
                    <EM><SPAN LANG="en">... remainder omitted for brevity ...</SPAN></EM>
                <SPAN LANG="en">&amp;amp;lt;/jxta:PA&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;/PeerAdv&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Response Expiration=&quot;7200000&quot;&gt;</SPAN>
                <SPAN LANG="en">&amp;amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

                <SPAN LANG="en">&amp;amp;lt;!DOCTYPE jxta:PipeAdvertisement&gt;</SPAN>

                <SPAN LANG="en">&amp;amp;lt;jxta:PipeAdvertisement xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
                    <SPAN LANG="en">&amp;amp;lt;Id&gt;</SPAN>
                        <SPAN LANG="en">urn:jxta:uuid-59616261646162614E50472050325033D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D104</SPAN>
                    <SPAN LANG="en">&amp;amp;lt;/Id&gt;</SPAN>
                    <SPAN LANG="en">&amp;amp;lt;Type&gt;</SPAN>
                        <SPAN LANG="en">JxtaPropagate</SPAN>
                    <SPAN LANG="en">&amp;amp;lt;/Type&gt;</SPAN>
                    <SPAN LANG="en">&amp;amp;lt;Name&gt;</SPAN>
                        <SPAN LANG="en">JxtaTalkUserName.IP2PGRP</SPAN>
                    <SPAN LANG="en">&amp;amp;lt;/Name&gt;</SPAN>
                <SPAN LANG="en">&amp;amp;lt;/jxta:PipeAdvertisement&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;/Response&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;/jxta:DiscoveryResponse&gt;</SPAN>
    <SPAN LANG="en">&lt;/Response&gt;</SPAN>
<SPAN LANG="en">&lt;/jxta:ResolverResponse&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-prp-rsm"></A>3.1.4.&nbsp;Resolver
SRDI Message</H3>
<P><SPAN LANG="en">The resolver SRDI message is used to send a
resolver </SPAN><SPAN LANG="en">SRDI</SPAN><SPAN LANG="en"> message
to the named handler on one or more peers that are members of the
peer group. The resolver </SPAN><SPAN LANG="en">SRDI</SPAN><SPAN LANG="en">
message is sent to a specific handler. The payload string may be any
string that will be interpreted by the targeted handler.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="frsrdis"></A><B>Figure&nbsp;3.3.&nbsp;Resolver
SRDI Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">ResolverSRDI</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:ResolverSRDI&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;ResolverSRDI&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:all&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;HandlerName&quot; type=&quot;xs:string&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:Cred&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Payload&quot; type=&quot;xs:anyType&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:all&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;HandlerName&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	A string that specifies the destination of this message. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;jxta:Cred&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The credential of the sender. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Payload&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Contains the payload. 
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="frsrdie"></A><B>Example&nbsp;3.3.&nbsp;Resolver SRDI</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;

<SPAN LANG="en">&lt;!DOCTYPE jxta:ResolverSRDI&gt;</SPAN>

<SPAN LANG="en">&lt;jxta:ResolverSRDI xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;HandlerName&gt;</SPAN>
        <SPAN LANG="en">urn:jxta:uuid-DEADBEEFDEAFBABAFEEDBABE0000000305</SPAN>
    <SPAN LANG="en">&lt;/HandlerName&gt;</SPAN>
    <SPAN LANG="en">&lt;jxta:Cred&gt;</SPAN>
        <SPAN LANG="en">JXTACRED</SPAN>
    <SPAN LANG="en">&lt;/jxta:Cred&gt;</SPAN>
    <SPAN LANG="en">&lt;Payload&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:GenSRDI&gt;</SPAN>
                    <EM><SPAN LANG="en">... remainder omitted for brevity ...</SPAN></EM>
        <SPAN LANG="en">&amp;lt;/jxta:GenSRDI&gt;</SPAN>
    <SPAN LANG="en">&lt;/Payload&gt;</SPAN>
<SPAN LANG="en">&lt;/jxta:ResolverSRDI&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="id292845"></A>3.1.5.&nbsp;Listener
and Element Naming</H3>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
communicates by exchanging Messages using the Endpoint Service.
Endpoint Addresses specify a handler name. The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
attaches a listener by that name to the <A HREF="#trans-endpt">Endpoint
Service</A>.</SPAN></P>
<P><SPAN LANG="en">All </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
implementations must use the same scheme for building their handler
names. The convention used by all services of the world peer group is
to use the concatenation of the service name, the peer group ID, and
a value unique within the service.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="flnsa"></A><B>Figure&nbsp;3.4.&nbsp;Listener
Naming Syntax ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;JXTARSLVRRSQRY&gt;   ::= &lt;JXTARSLVRNAM&gt; &lt;JXTAIDVAL&gt; &lt;JXTARSLVRQRYTAG&gt;

<SPAN LANG="en">&lt;JXTARSLVRRSRSP&gt;   ::= &lt;JXTARSLVRNAM&gt; &lt;JXTAIDVAL&gt; &lt;JXTARSLVRRSPTAG&gt;</SPAN>

<SPAN LANG="en">&lt;JXTARSLVRRSSRDI&gt;  ::= &lt;JXTARSLVRNAM&gt; &lt;JXTAIDVAL&gt; &lt;JXTARSLVRSRDITAG&gt;</SPAN>

<SPAN LANG="en">&lt;JXTARSLVRQRYTAG&gt;  ::= &quot;ORes&quot;</SPAN>

<SPAN LANG="en">&lt;JXTARSLVRRSPTAG&gt;  ::= &quot;IRes&quot;</SPAN>

<SPAN LANG="en">&lt;JXTARSLVRSRDITAG&gt; ::= &quot;Isrdi&quot;</SPAN>

<SPAN LANG="en">&lt;JXTARSLVRNAM&gt;     ::= &quot;jxta.service.resolver&quot;</SPAN>

<SPAN LANG="en">&lt;JXTAIDVAL&gt;        ::= </SPAN><EM><SPAN LANG="en">See <A HREF="#ids-fjia">JXTA ID ABNF</A></SPAN></EM></PRE><P>
<BR><BR>
</P>
<P><SPAN LANG="en">The listeners used by the </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
are named as follows:</SPAN></P>
<DL>
	<DT LANG="en">Queries 
	</DT><DD>
	<SPAN LANG="en">jxta.service.resolver[group unique Id string]ORes
	(</SPAN><EM><SPAN LANG="en">ORes</SPAN></EM><SPAN LANG="en"> is a
	literal string) </SPAN>
	</DD><DT LANG="en">
	Responses 
	</DT><DD>
	<SPAN LANG="en">jxta.service.resolver[group unique Id string]IRes
	(</SPAN><EM><SPAN LANG="en">IRes</SPAN></EM><SPAN LANG="en">is a
	literal string) </SPAN>
	</DD><DT LANG="en">
	Srdi 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">jxta.service.resolver[group unique Id string]Isrdi
	(</SPAN><EM><SPAN LANG="en">Isrdi</SPAN></EM><SPAN LANG="en"> is a
	literal string) </SPAN>
	</DD></DL>
<P LANG="en">
Query and response messages are included in messages as elements
named as follows:</P>
<UL TYPE=DISC>
	<LI><P STYLE="margin-bottom: 0cm"><EM><SPAN LANG="en">Queries</SPAN></EM><SPAN LANG="en">:
	[group unique Id string]ORes (</SPAN><EM><SPAN LANG="en">ORes</SPAN></EM><SPAN LANG="en">
	is a literal string) </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><EM><SPAN LANG="en">Responses</SPAN></EM><SPAN LANG="en">:
	[group unique Id string]IRes (</SPAN><EM><SPAN LANG="en">IRes</SPAN></EM><SPAN LANG="en">
	is a literal string) </SPAN>
	</P>
	<LI><P><EM><SPAN LANG="en">Srdi</SPAN></EM><SPAN LANG="en">: [group
	unique Id string]Isrdi (</SPAN><EM><SPAN LANG="en">Isrdi</SPAN></EM><SPAN LANG="en">
	is a literal string) </SPAN>
	</P>
</UL>
<H3 LANG="en" CLASS="title"><A NAME="id293009"></A>3.1.6.&nbsp;Behaviour</H3>
<H4 LANG="en" CLASS="title"><A NAME="id293014"></A>3.1.6.1.&nbsp;Handler
Name</H4>
<P><SPAN LANG="en">The Handler Name in </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
messages plays a role similar to that of the handler name in the
Endpoint Message addresses: it is a demultiplexing key that specifies
how, by which higher-level protocol, or by which module, the message
is to be processed.</SPAN></P>
<P><SPAN LANG="en">In the Java and &ldquo;C&rdquo; reference
implementations, the users of the </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
are typically services. Each instance of a given service (one per
peer per group that uses this service) generates a handler name that
is unique on its peer, but will be identical for the instances of
this service on other peers. This is by convention achieved by
concatenating the service name (which is unique in the group), the
group id, which is unique in the peer, and a additional parameter
which serves to discriminate between several handlers used by the
same service, if needed.</SPAN></P>
<P LANG="en">The handler name is used both to register the
appropriate handler for incoming queries or responses, and as a
destination for outgoing queries or responses. For convenience, most
clients of the resolver do define two names: one for propagated
messages (mostly queries), and one for unicast messages (mostly
responses).</P>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
typically uses the Rendezvous Service to disseminate a query to
multiple peers or unicast messages to send queries to specified
peers.</SPAN></P>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
should refuse, and the existing reference implementations shall
refuse the registration of more than one handler with the same name.
A service should register for any handler name that it uses as a
destination, thereby preventing other services from registering
themselves to receive these messages. This means that in principle a
service or application that receives queries or responses from a
service instance on another peer is de-facto the local instance of
that service and should handle these messages as specified. </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
is designed for same-to-same communication, not client-server.</SPAN></P>
<H4 LANG="en" CLASS="title"><A NAME="id293096"></A>3.1.6.2.&nbsp;Policies
and Quality of Service</H4>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
does not guarantee peers that define a query handler name will
receive that query, nor does it mandate that all peers that define
this handler name will receive it. Only a best effort is made at
disseminating the query in a way that maximizes the chance of
obtaining a response, if one can be obtained.</SPAN></P>
<P LANG="en">There is no guarantee that a response to a resolver
query request will be made. It is important to point that response to
a ResolverQuery request is optional. A peer is not required to
respond.</P>
<P LANG="en">There is no guarantee that a Resolver SRDI Message will
be honored. It is important to point out that accepting a Resolver
SRDI Message is optional. A peer is not required to accept the
message.</P>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
does not assume the presence of reliable message delivery. Multiple
Resolver query messages may be sent--none, one, multiple or redundant
responses may be received.</SPAN></P>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
provides a generic mechanism for services to send queries, and
receive responses and SRDI messages. As a service, the reference
implementation helps other services by taking care of all messaging
aspects, caching queries responses, and SRDI messages and in
forwarding queries, based on the invoker's decision. The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">
performs authentication, and verification of credentials and drops
incorrect messages.</SPAN></P>
<P><SPAN LANG="en">The actual task of propagating a query to the next
set of peers is delegated to the <A HREF="#proto-rvp">Rendezvous
Protocol</A>. The Rendezvous service is responsible for determining
the set of peers that should receive a message being propagated, but
never automatically re-propagates an incoming propagated message. It
is left to the service (query handler) handling the message to
determine if further propogation should be performed. The </SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">'s
policy is the following: if the query handler does not instruct the
</SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en"> to discard the
query, and if the local peer is a rendezvous, then the query is
re-propagated (within the limits of loop and </SPAN><SPAN LANG="en">TTL</SPAN><SPAN LANG="en">
rules enforced by the Rendezvous service). In addition, if instructed
by the query handler, an identical query may be issued with the local
peer as the originator.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="proto-erp"></A>3.2.&nbsp;Endpoint
Routing Protocol</H2>
<P LANG="en">The JXTA network is ad hoc, multi-hop, and adaptive by
nature. Connections in the network may be transient, and message
routing is nondeterministic. Routes may be unidirectional and change
rapidly. Peers may join and leave frequently. A peer inside a
firewall can send a message directly to a peer outside a firewall.
But a peer outside the firewall cannot establish a connection
directly with a peer inside the firewall.</P>
<P><SPAN LANG="en">The Endpoint Routing Protocol (</SPAN><SPAN LANG="en">ERP</SPAN><SPAN LANG="en">)
defines a set of request/query messages that are processed by a
routing service to help a peer route messages to their destination.</SPAN></P>
<P LANG="en">When a peer is asked to send a message to a given peer
endpoint address, it looks in its local cache to see if it has a
route to this peer. If it does not find a route, it sends a route
resolver query message to its available peer routers asking for
routing information. A peer can have as many peer routers as it can
find or they can be pre-configured. Pre-configured routers are
optional.</P>
<P><SPAN LANG="en">The peer routers provide the low-level
infrastructure to route messages between two peers in the network.
Any number of peers in a peergroup can elect themselves to become
peer routers for other peers. Peers routers offer the ability to
cache route information, as well as bridging different physical or
logical networks. A peer can dynamically find its router peer via a
qualified discovery search. A peer can find out if a peer it has
discovered is a peer router via the peer advertisement </SPAN><CODE><SPAN LANG="en">&lt;Parms&gt;</SPAN></CODE><SPAN LANG="en">
element.</SPAN></P>
<P LANG="en">When a peer router receives a route query, if it knows a
route to the destination, it answers the query by returning the route
information as an enumeration of hops. Once a route has been
discovered, a message can be sent to the first router and that router
will use the route information to route the message to the
destination peer. The route is ordered from the next hop to the final
destination peer. At any point the routing information may become
obsolete requiring the current router to discover a new route in
order to complete the message delivery.</P>
<P LANG="en">The peer endpoint adds extra routing information to the
messages sent by a peer. When a message goes through a peer, the
endpoint of that peers leaves its trace on the message. The trace can
be used for loop detection, and to discard recurrent messages. The
trace is also used to record new route information by peer routers.</P>
<P LANG="en">ERP provides last resort routing for a peer. More
intelligent routing can be implemented by more sophisticated routing
services in place of the core routing service. High-level routing
services can manage and optimize routes more efficiently than the
core service. JXTA intends is to provide the hooks necessary for user
defined routing services to manipulate and update the route table
information (route advertisements) used by the peer router. The
intent is to have complex route analysis and discovery be performed
above the core by high-level routing services, and have those routing
services provide intelligent hints to the peer router to route
messages.</P>
<P LANG="en">The Endpoint Routing Protocol is used to find the
available routes to send a message to a destination peer. This is
accomplished through message exchanges between peer routers. Peer
routing may be necessary to enable two peers to communicate depending
on their location in the network. For instance, the two peers may be
on different transports; the peers may be separated by a firewall; or
may be using incompatible private IP address spaces. When necessary
one or more peer routers can be used to deliver a message from the
originating peer endpoint to the destination peer endpoint.</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-erp-epa"></A>3.2.1.&nbsp;Endpoint
Addresses</H3>
<P LANG="en">JXTA Endpoints are identified using URIs known as
Endpoint Addresses. Endpoint Addresses can describe both physical
network locations and virtual addresses for peers and groups.</P>
<P LANG="en" CLASS="title"><A NAME="id293298"></A><B>Figure&nbsp;3.5.&nbsp;Endpoint
Address URI ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;ENDPOINTADDRESS&gt;  ::= (&lt;URISCHEME&gt; &lt;PROTOCOLADDR&gt; 0*1(&quot;/&quot; &lt;RECIPIENT&gt; &quot;/&quot; 0*1(&lt;RECIPIENTPARAM&gt;))) |
                       <SPAN LANG="en">(&lt;URNSCHEME&gt; &lt;PROTOCOLADDR&gt; 0*1(&quot;#&quot; &lt;RECIPIENT&gt; &quot;/&quot; 0*1(&lt;RECIPIENTPARAM&gt;)))</SPAN>

<SPAN LANG="en">&lt;PROTOCOL&gt;         ::= &lt;URISCHEME&gt; | &lt;URNSCHEME&gt;</SPAN>

<SPAN LANG="en">&lt;URISCHEME         ::= 1 (&lt;upper&gt; | &lt;lower&gt;) 0* &lt;URICHARS&gt; &lt;SCHEMESEP&gt;</SPAN>

<SPAN LANG="en">&lt;SCHEMESEP&gt;        ::= &quot;:&quot; | &quot;://&quot;</SPAN>

<SPAN LANG="en">&lt;URNSCHEME         ::= &quot;urn:&quot; 1 (&lt;upper&gt; | &lt;lower&gt;) 0* &lt;URICHARS&gt; &quot;:&quot;</SPAN>

<SPAN LANG="en">&lt;URICHARS&gt;         ::= &lt;upper&gt; | &lt;lower&gt; | &lt;number&gt; | &quot;%&quot; &lt;hex&gt; &lt;hex&gt;</SPAN>

<SPAN LANG="en">&lt;PROTOCOLADDR&gt;     ::= 0* (&lt;URICHARS&gt; |  &lt;other&gt;)</SPAN>

<SPAN LANG="en">&lt;RECIPIENT&gt;        ::= 0* (&lt;URICHARS&gt; |  &lt;other&gt;)</SPAN>

<SPAN LANG="en">&lt;RECIPIENTPARAM&gt;   ::= 0* &lt;URN chars&gt;</SPAN>

<EM><SPAN LANG="en">see <A HREF="#ids-fjia">JXTA ID ABNF</A> for definition of some terms.</SPAN></EM></PRE><P>
<BR><BR>
</P>
<P LANG="en" CLASS="title"><A NAME="id293326"></A><B>Example&nbsp;3.4.&nbsp;Endpoint
Address URI Examples</B></P>
<PRE LANG="en" CLASS="programlisting">http://192.168.0.11:9700/endpoint/resolver

<SPAN LANG="en">urn:jxta:uuid-59616261646162614E50472050325033D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D104?pipeService</SPAN>

<SPAN LANG="en">urn:jxta:jxta-NetGroup?relay/uuid-59616261646162614A7874615032503369D1041721754AD18D7D9137C06F77DD03</SPAN></PRE><P>
<BR><BR>
</P>
<P LANG="en">The Endpoint Service delegates the sending of outgoing
messages to the endpoint protocol designated by the &lt;PROTOCOL&gt;
part of the message's destination address.</P>
<P LANG="en">The Endpoint Service delivers incoming messages to the
listener registered under the name that matches in order of
preference :</P>
<UL TYPE=DISC>
	<LI><P><SPAN LANG="en">The </SPAN><CODE><SPAN LANG="en">&lt;RECIPIENT&gt;</SPAN></CODE><SPAN LANG="en">
	and </SPAN><CODE><SPAN LANG="en">&lt;RECIPIENTPARAM&gt;</SPAN></CODE><SPAN LANG="en">
	seperated by a </SPAN><CODE><SPAN LANG="en">/</SPAN></CODE><SPAN LANG="en">.</SPAN></P>
	<LI><P><SPAN LANG="en">The </SPAN><CODE><SPAN LANG="en">&lt;RECIPIENT&gt;</SPAN></CODE><SPAN LANG="en">.</SPAN></P>
</UL>
<H3 LANG="en" CLASS="title"><A NAME="proto-erp-ri"></A>3.2.2.&nbsp;Route
information</H3>
<P LANG="en">Route information is represented as follow:</P>
<P LANG="en" CLASS="title"><A NAME="feprra"></A><B>Figure&nbsp;3.6.&nbsp;Route
Advertisement</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">APA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:APA&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name =&quot;jxta:APA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PID&quot; minOccurs=&quot;0&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;EA&quot; type=&quot;xs:anyURI&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">RA</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:RA&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name =&quot;jxta:RA&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;DstPID&quot; minOccurs=&quot;0&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Dst&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:APA&quot; maxOccurs=&quot;1&quot;/&gt;</SPAN>
      <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Hops&quot; minOccurs=&quot;0&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:APA&quot; maxOccurs=&quot;unbounded&quot;/&gt;</SPAN>
      <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;PID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">The Peer ID of the peer described by this
	advertisement. When not included the advertisement is used in a
	context where the Peer ID is already known, such as in the </SPAN><CODE><SPAN LANG="en">&lt;Dst&gt;</SPAN></CODE><SPAN LANG="en">
	element of a Route Advertisement. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;EA&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	An Endpoint Address for the peer. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;DstPID&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The Peer ID of the peer described by this advertisement. When not
	included the advertisement is used in a context where the Peer ID is
	already known, such as in a Peer Advertisement. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Dst&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Contains an Access Point Advertisement containing a list of endpoint
	addresses associated with the specified peer id. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Hops&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">A semi-ordered collection of Access Point
	Advertisements describing a route to the peer indicated by </SPAN><CODE><SPAN LANG="en">&lt;DstPID&gt;</SPAN></CODE><SPAN LANG="en">.
	The individual steps of the route are co-mingled with routing
	alternatives. As the route is traversed peers route messages by
	forwarding to the earliest peer in the list that they can reach. </SPAN>
	</DD></DL>
<P LANG="en">
The time-to-live parameter is measured in hops and specifies how long
this route is valid. The creator of the route can decide how long
this route will be valid. The gateways are defined as an ordered
sequence of peer IDs which define the route from the source peer to
the destination peer. The sequence may not be complete, but at least
the first gateway should be present. The first gateway is sufficient
to initially route the messages. The remaining gateway sequence is
optional.</P>
<P LANG="en">Peer routers will typically cache route information. Any
peer can query a peer router for route information. Any peer in a
peer group may become a peer router.</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-erp-rqm"></A>3.2.3.&nbsp;Route
Query Message</H3>
<P><SPAN LANG="en">This message is sent by peers to request route
information for another peer. Route Query Messages are transmitted as
queries within <A HREF="#proto-prp-rqm">Resolver Query Message</A>.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="feprq"></A><B>Figure&nbsp;3.7.&nbsp;Endpoint
Router Query</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">ERQ</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:ERQ&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name =&quot;jxta:ERQ&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Dst&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Src&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:RA&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;Dst&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The peer id of the peer who's route is desired. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Src&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Route advertiement of the peer requesting route information. This
	route information is needed to ensure there is a return route for
	responses. 
	</DD></DL>
<H3 LANG="en" CLASS="title">
<A NAME="proto-erp-rrm"></A>3.2.4.&nbsp;Route Response Message</H3>
<P><SPAN LANG="en">This message is sent by peers in response to Route
Query Messages. The Route Response Message contains a route
advertisement for the destination peer. Route Response Messages are
transmitted as responses within <A HREF="#proto-prp-rrm">Resolver
Response Message</A>.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="feprrm"></A><B>Figure&nbsp;3.8.&nbsp;Endpoint
Router Response Message</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">ERR</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:ERR&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name =&quot;jxta:ERR&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Dst&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:RA&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Src&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:RA&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;Dst&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The Route Advertisement for the peer which was requested in the
	Endpoint Router Query. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Src&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Route Advertiement for the destination peer. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="core-trans"></A>Chapter&nbsp;4.&nbsp;Core JXTA Message
Transport Bindings</H2>
<H2 LANG="en" CLASS="title"><A NAME="trans-endpt"></A>4.1.&nbsp;Endpoint
Service</H2>
<H3 LANG="en" CLASS="title"><A NAME="trans-endpt-desc"></A>4.1.1.&nbsp;Description</H3>
<P LANG="en">The Endpoint Service is responsible for performing
end-to-end messaging between two JXTA peers, using one of the
underlying JXTA transport protocols, such as the JXTA TCP or HTTP
bindings.</P>
<P LANG="en">The Endpoint Service is primarily used by other services
or applications that need to have an understanding of the network
topology, such as the Resolver Service or the Propagation Service.</P>
<P><SPAN LANG="en">The Endpoint Service is not responsible for
routing messages for peers that are not directly connected to each
other. This task is performed by the <A HREF="#trans-router">Endpoint
Router Transport Protocol</A>which provides the illusion that the
source and destination peers are directly connected.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="trans-endpt-protocol"></A>4.1.2.&nbsp;Protocol</H3>
<P LANG="en">When the Endpoint Service transmits a message it may add
a single element to the message: the source peer ID.</P>
<P><SPAN LANG="en">The element name is: </SPAN><CODE><SPAN LANG="en">jxta:EndpointHeaderSrcPeer</SPAN></CODE><SPAN LANG="en">and
its value is a textual UTF-8 representation of the peer ID at the
point of emission of the message. This information is optional and is
used by the emitter endpoint service itself to detect and eliminate
progagated messages that loop back to the emitter.</SPAN></P>
<P LANG="en">If this element is not present the message is assumed to
not be looping back.</P>
<P LANG="en">The endpoint service expects incoming and outgoing
messages to have a source address and a destination address. The
encapsulation of that information is specified by the message wire
format being used.</P>
<P LANG="en">Two additional common elements are optionally used by
Message Transports in conjunction with the Endpoint Service. Message
Transports may typically provide received messages to the Endpoint
Service containing these elements and the Endpoint service will
dispatch the messages based upon their content. Message Transports
may use alternate mechanisms for determining message source and
destination addresses and need not use these elements.</P>
<P><SPAN LANG="en">The </SPAN><CODE><SPAN LANG="en">jxta:EndpointSourceAddress</SPAN></CODE><SPAN LANG="en">
contains an Endpoint Address for the source of this message. The
source address has a variety of meanings based upon the usage of the
underlying Message Transport. For low level transports such as </SPAN><SPAN LANG="en">TCP</SPAN><SPAN LANG="en">
or </SPAN><SPAN LANG="en">HTTP</SPAN><SPAN LANG="en"> the source
address is the return address of the peer from which the message was
received, ie. the hop address. For higher level Message Transports
such as the Endpoint Router Transport or the </SPAN><SPAN LANG="en">TLS</SPAN><SPAN LANG="en">
transport the source addresss is the virtual Endpoint Address of the
peer which originated the message regardless of any intervening hops
the message may have made.</SPAN></P>
<P><SPAN LANG="en">The </SPAN><CODE><SPAN LANG="en">jxta:EndpointDestinationAddress</SPAN></CODE><SPAN LANG="en">
contains an Endpoint Address which will be used by the Endpoint
Service to dispatch a received message to the recipient specified by
the service name and service parameter. The protocol address is also
provided to the recipient service and can be used in some protocols
for determining how the message was received. For example a service
may wish to handle messages which were sent directly differently than
messages which were sent via propagation.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="trans-router"></A>4.2.&nbsp;Endpoint
Router Transport Protocol</H2>
<H3 LANG="en" CLASS="title"><A NAME="trans-router-descr"></A>4.2.1.&nbsp;Description</H3>
<P LANG="en">The Endpoint Router is a logical JXTA Transport Protocol
that sits below the Endpoint Service and beside the other Transport
Protocols such as the JXTA TCP and HTTP Transport Protocols.</P>
<P LANG="en">The Endpoint Router is responsible for exchanging
messages between peers that do not have a direct connection between
each other. The Endpoint Router provides a virtual direct connection
to the peer's Endpoint Service.</P>
<H3 LANG="en" CLASS="title"><A NAME="trans-router-proto"></A>4.2.2.&nbsp;Protocol</H3>
<P LANG="en">The Endpoint Router protocol defines a set of queries
and responses used to communicate with instances of the Endpoint
Router on other peers.</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Route Query: when the
	Endpoint Router is requested to send a message to a peer for which
	it does not have yet a route for, it sends a Route Query request to
	other peers. Peers that have an route for the given peer answers
	with Route Response. 
	</P>
	<LI><P LANG="en">Route Response: a peer that desires inform another
	peer about a give route sends a Route Response to the peer. A Route
	Response is replied following up a Route Query. 
	</P>
</UL>
<P LANG="en">In addition, the Endpoint Router defines an
informational message that requires no reply.</P>
<UL TYPE=DISC>
	<LI><P LANG="en">NACK: a NACK is sent by any peer that detects that
	a route used by another peer is not valid. Typically, this happens
	by a router peer that are requested to route a message to peer for
	which it does not have a route itself. NACK messages are optional:
	routers are not required to send them, and while a NACK is typically
	sent to the source peer of the message, peers can send NACK to other
	peers of their choice. 
	</P>
</UL>
<P LANG="en">These messages are sent and received by the
EndpointRouter using the JXTA Resolver Service.</P>
<H3 LANG="en" CLASS="title"><A NAME="trans_router_msg"></A>4.2.3.&nbsp;EndpointRouter
Message Element</H3>
<P><SPAN LANG="en">The Endpoint Router Transport Protocol appends its
own message element to each message it transports. The name of the
message element is </SPAN><CODE><SPAN LANG="en">JxtaEndpointRouter</SPAN></CODE><SPAN LANG="en">and
contains an XML document containing the following:</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="feprme"></A><B>Figure&nbsp;4.1.&nbsp;Endpoint
Router Message Element</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:element name=&quot;ERM&quot; type=&quot;jxta:ERM&quot;/&gt;

<SPAN LANG="en">&lt;xs:complexType name=&quot;ERM&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Src&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Dest&quot; type=&quot;xs:anyURI&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;LastHop&quot; minOccurs=&quot;0&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Fwd&quot;&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:complexType&gt;</SPAN>
                <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
                    <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:APA&quot; maxOccurs=&quot;unbounded&quot; /&gt;</SPAN>
                <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
            <SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>
        <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Rvs&quot; minOccurs=&quot;0&quot;&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:complexType&gt;</SPAN>
                <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
                    <SPAN LANG="en">&lt;xs:element ref=&quot;jxta:APA&quot; maxOccurs=&quot;unbounded&quot; /&gt;</SPAN>
                <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
            <SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>
        <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;Src&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The peer id of the originator of this message. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Dest&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The Endpoint Address of the intended final destination of this
	message. Includes final routing information of the service name and
	service parameter. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;LastHop&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The peer id of the most recent peer to forward this message. When a
	peer forwards a message, it should update this field with its own
	Endpoint Address. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Fwd&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">A loosely ordered list of Access Point
	Advertisements which describe a probable route for this message.
	Loosely ordered because it may describe alternative routes. In order
	to route the message peers should scan the list for the </SPAN><EM><SPAN LANG="en">last</SPAN></EM><SPAN LANG="en">
	peer for which they recognize and route message via that peer. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Rvs&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	An ordered array of Access Point Advertisements which describe the
	known reverse route for this message. This is the path which the
	message has traveled thus far. Due to unidirectional links this
	route may not be suitable for sending response messages. 
	</DD></DL>
<H4 LANG="en" CLASS="title">
<A NAME="trans-router-addr"></A>4.2.3.1.&nbsp;EndpointRouter Endpoint
Address format</H4>
<P LANG="en">Since the EndpointRouter is a transport protocol, it has
its own Endpoint Address format, which is:</P>
<P LANG="en" CLASS="title"><A NAME="fjera"></A><B>Figure&nbsp;4.2.&nbsp;JXTA
Endpoint Router Address Format</B></P>
<PRE CLASS="programlisting" STYLE="margin-bottom: 0.5cm"><SPAN LANG="en">jxta://</SPAN><EM><SPAN LANG="en">[PeerID unique value]</SPAN></EM></PRE><P LANG="en">
<BR><BR>
</P>
<H2 LANG="en" CLASS="title"><A NAME="msgs"></A>Chapter&nbsp;5.&nbsp;Messages</H2>
<H2 LANG="en" CLASS="title"><A NAME="id295839"></A>5.1.&nbsp;Introduction</H2>
<P><SPAN LANG="en">Messages are the basic unit of data exchange
between peers. Pipes send and receive messages to and from services;
any protocol implemented by a service will send and receive messages.
Messages are encoded using &ldquo;wire&rdquo; representations for
transmission. Each JXTA transport will use the message
representations most appropriate for its characteristics and the
peers' preferences. See <A HREF="#msgs-fmts">JXTA Message Wire
Representations</A> for information about representations.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="id296192"></A>5.2.&nbsp;Message</H2>
<P LANG="en">A message is a set of named and typed contents called
elements. Thus a message is essentially a set of name/value pairs.
The content can be an arbitrary type. Many core services send XML
advertisements as message element contents.</P>
<P LANG="en">As a message passes down the JXTA protocol stack
(applications, services, endpoint and transports), each level may add
one or more named elements to the message. As a message is passed
back up the stack on the receiving peer, the protocol handlers should
remove those elements.</P>
<P LANG="en">A message is an ordered sequence of message elements.
The most recently added element appears at the end of the message.</P>
<H2 LANG="en" CLASS="title"><A NAME="id296221"></A>5.3.&nbsp;Element</H2>
<P LANG="en">A message element contains a namespace, an optional
name, an optional type, an optional signature or digest and content.</P>
<H3 LANG="en" CLASS="title"><A NAME="msgs-namespace"></A>5.3.1.&nbsp;Namespace</H3>
<P LANG="en">Every element is assigned to a namespace. Namespaces are
used to organize elements used by different message users and
transports within the same message.</P>
<P><SPAN LANG="en">Two namespaces names are considered equivalent if
their representation in canonical UTF8 (NFC) (see </SPAN><EM><SPAN LANG="en">Unicode
Standard Annex #15 : Unicode Normalization Forms</SPAN></EM><SPAN LANG="en">
<A HREF="#bib-USA15">USA15</A>) is byte-for-byte identical.</SPAN></P>
<P><SPAN LANG="en">Two message element namespaces are pre-defined, </SPAN><CODE><SPAN LANG="en">&quot;&quot;</SPAN></CODE><SPAN LANG="en">
(empty string) and </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">.
The </SPAN><CODE><SPAN LANG="en">&quot;&quot;</SPAN></CODE><SPAN LANG="en">
namespace is reserved for user applications and services--none of the
JXTA protocols or services will use or modify elements in this
namespace.</SPAN></P>
<P><SPAN LANG="en">The </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace is reserved for internal use by the JXTA protocols and
services. Applications should not create, manipulate or assume the
interpretation of any of the content of elements in the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace. In some bindings, applications may be forbidden from
accessing or creating elements in the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace.</SPAN></P>
<P LANG="en">Use of namespaces by services and applications other
than the &quot;&quot; namespace is optional. Namespaces require no
formal registration as the protocols used need only be agreed upon by
the participants.</P>
<H3 LANG="en" CLASS="title"><A NAME="msgs-name"></A>5.3.2.&nbsp;Name</H3>
<P LANG="en">Elements may have an optional name. Elements in the same
message may have the same name.</P>
<H3 LANG="en" CLASS="title"><A NAME="msgs-type"></A>5.3.3.&nbsp;Type</H3>
<P><SPAN LANG="en">A type is specified as a MIME type. See <A HREF="#bib-RFC2046">RFC2046</A>.
The MIME type is encoded in canonical UTF8 (NFC) using the
presentation and encoding of </SPAN><EM><SPAN LANG="en">Multipurpose
Internet Mail Extensions (MIME) Part Two: Media Types</SPAN></EM><SPAN LANG="en">
<A HREF="#bib-RFC2046">RFC2046</A>, ie. any encoding specified by RFC
2046 is performed before the string is encoded into UTF8 from its
native representation.</SPAN></P>
<P LANG="en">The type is used by the applications and services that
process the element. There is no restriction on the set of MIME types
that can be used by applications and services. In addition to the
applications and services which use the particular element, the type
of the element may also be examined by the JXTA message transport to
determine how to format the message element to ensure the most
effcient transfer.</P>
<P LANG="en">If the type is not specified for an element
&quot;application/octet-stream&quot; is assumed.</P>
<H3 LANG="en" CLASS="title"><A NAME="id296383"></A>5.3.4.&nbsp;Content</H3>
<P LANG="en">The contents of the Element data are opaque to except to
the applications and services which use these elements.</P>
<H1 LANG="en" CLASS="title"><A NAME="stdsvc"></A>Part&nbsp;2.&nbsp;JXTA
Standard Services</H1>
<H1 LANG="en" CLASS="title"><A NAME="stdsvc-i"></A>Introduction</H1>
<P><SPAN LANG="en">The <A HREF="#core">JXTA Core Specification</A>
defines the required components and behaviours for all JXTA
implementations. In order to create a complete JXTA implementation
there are some additional components which all implementation should
provide.</SPAN></P>
<P><SPAN LANG="en">The </SPAN><EM><A HREF="#gloss-jss"><SPAN LANG="en">JXTA
Standard Services</SPAN></A></EM><SPAN LANG="en"> are optional JXTA
components and behaviours. Implementations are not required to
provide these services, but are strongly recommended to do so.
Implementing these services will provide greater interoperability
with other implementations and broader functionality.</SPAN></P>
<P LANG="en"><B>Table of Contents</B></P>
<DL>
	<DT><SPAN LANG="en"><A HREF="#stdsvc-proto">1. Standard Protocols</A>
	</SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#proto-pdp">1.1. Peer Discovery Protocol</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#proto-rvp">1.2. Rendezvous Protocol</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#proto-pip">1.3. Peer Information Protocol</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#proto-pbp">1.4. Pipe Binding Protocol</A>
		</SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#stdsvc-trans">2. Standard JXTA Message
	Transports</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#trans-tcpipt">2.1. TCP/IP Message
		Transport</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#trans-httpt">2.2. HTTP Message Transport</A>
		</SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#trans-tlst">2.3. TLS Transport Binding</A>
		</SPAN>
		</DT></DL>
	<DT>
	<SPAN LANG="en"><A HREF="#msgs-fmts">3. JXTA Message Wire
	Representations</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#id310772">3.1. General Requirements</A> </SPAN>
		</DT><DT>
		<SPAN LANG="en"><A HREF="#msgs-fmts-jbm">3.2. Binary Message Format</A>
		</SPAN>
		</DT><DT STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en"><A HREF="#id311199">3.3. XML Message Format</A> </SPAN>
		</DT></DL>
</DL>
<H2 LANG="en" CLASS="title">
<A NAME="stdsvc-proto"></A>Chapter&nbsp;1.&nbsp;Standard Protocols</H2>
<H2 LANG="en" CLASS="title"><A NAME="proto-pdp"></A>1.1.&nbsp;Peer
Discovery Protocol</H2>
<H3 LANG="en" CLASS="title"><A NAME="proto-pdp-intro"></A>1.1.1.&nbsp;Introduction</H3>
<P LANG="en">The Peer Discovery Protocol is used to discover any
published peer resource. Resources are represented as advertisements.
A resource can be a peer, a peergroup, a pipe, a module, or any
resource that has an advertisement. Each resource must be represented
by an advertisement.</P>
<P LANG="en">The Peer Discovery Protocol (PDP) enables a peer to find
advertisements in its group. The PDP protocol is the discovery
protocol of the world peergroup. Custom discovery services may choose
to leverage PDP. If a peer group does not need to define its own
discovery protocol, it may use the world peergroup PDP.</P>
<P LANG="en">The intent is for PDP to provide the essential discovery
infrastructure for building and bootstrapping high-level discovery
services. In many situation, discovery information is better known by
a high-level service, because the service may have a better knowledge
of the group topology.</P>
<P LANG="en">The PDP protocol provides a basic mechanism to discover
advertisements while providing hooks so high-level services and
applications can participate in the discovery process. Services
should be able to give hints to improve discovery (i.e. decide which
advertisements are the most valuable to cache).</P>
<P LANG="en">The PDP protocol utilizes the resolver protocol to route
queries and responses.</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-pdp-dqm"></A>1.1.2.&nbsp;Discovery
Query Message</H3>
<P LANG="en">The discovery query message is used by peers to send
discovery requests when searching for advertisements.</P>
<P LANG="en" CLASS="title"><A NAME="fdqs"></A><B>Figure&nbsp;1.1.&nbsp;Discovery
Query Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">DiscoveryQuery</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:DiscoveryQuery&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xsd:simpleType name=&quot;DiscoveryQueryType&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xsd:restriction base=&quot;xsd:string&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- peer --&gt;</SPAN>
    <SPAN LANG="en">&lt;xsd:enumeration value=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- group --&gt;</SPAN>
    <SPAN LANG="en">&lt;xsd:enumeration value=&quot;1&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- adv --&gt;</SPAN>
    <SPAN LANG="en">&lt;xsd:enumeration value=&quot;2&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xsd:restriction&gt;</SPAN>
<SPAN LANG="en">&lt;/xsd:simpleType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;DiscoveryQuery&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Type&quot; type=&quot;jxta:DiscoveryQueryType&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Threshold&quot; type=&quot;xs:unsignedInt&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Attr&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Value&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- The following should refer to a peer adv, but is instead a whole doc for historical reasons --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PeerAdv&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT STYLE="margin-bottom: 0.5cm"><CODE><SPAN LANG="en">&lt;Type&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Only advertisements of requested type will be matched. Possible
	values are:</DD><DL>
		<DT>
		<CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		Peer Advertisements 
		</DD><DT>
		<CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		Peergroup Advertisements 
		</DD><DT>
		<CODE><SPAN LANG="en">2</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		Any Advertisements 
		</DD></DL>
	<DT>
	<CODE><SPAN LANG="en">&lt;Threshold&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD>
	<SPAN LANG="en">specifies the maximum number of advertisements that
	each responding peer should provide. The total number of results
	received depends on the number of peers that respond and the
	advertisements they have. If </SPAN><CODE><SPAN LANG="en">&lt;Type&gt;</SPAN></CODE><SPAN LANG="en">
	is </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
	(Peer Advertisements) and </SPAN><CODE><SPAN LANG="en">&lt;Threshold&gt;</SPAN></CODE><SPAN LANG="en">
	is </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">,
	then the query has a special meaning: its objective is to collect
	Peer Advertisements of respondents. Therefore any peer should
	respond to such a query, e ven though no results are to be included.
	</SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;PeerAdv&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	If present, the advertisement of the requestor. 
	</DD><DT STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">&lt;Attribute&gt;</SPAN></CODE><SPAN LANG="en">,
	</SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">Must either be both present or absent. If absent,
	then each respondent should supply a random set of advertisements of
	the appropriate type up to </SPAN><CODE><SPAN LANG="en">&lt;Threshold&gt;</SPAN></CODE><SPAN LANG="en">
	count.</SPAN></DD><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">Only advertisements containing an element who's name
	matches </SPAN><CODE><SPAN LANG="en">&lt;Attribute&gt;</SPAN></CODE><SPAN LANG="en">
	and that also contains a value matching </SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	are eligible to be found. </SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	may begin or end with &quot;*&quot;, or both. In that case </SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	will match all values that end with or beginning with, or contain
	the rest of the string. If </SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	contains only &quot;*&quot; the result is unspecified. Some
	implementations may choose not match any advertisement for </SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	&quot;*&quot;.</SPAN></DD></DL>
<P LANG="en" CLASS="title">
<A NAME="fdqe"></A><B>Example&nbsp;1.1.&nbsp;Discovery Query</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    
<SPAN LANG="en">&lt;jxta:DiscoveryQuery&gt;</SPAN>
    <SPAN LANG="en">&lt;Type&gt;2&lt;/Type&gt;</SPAN>
    <SPAN LANG="en">&lt;Threshold&gt;1&lt;/Threshold&gt; </SPAN>
    <SPAN LANG="en">&lt;Attr&gt;Name&lt;/Attr&gt;</SPAN>
    <SPAN LANG="en">&lt;Value&gt;*sidus*&lt;/Value&gt;</SPAN>
    <SPAN LANG="en">&lt;PeerAdv&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:PA&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;jxta:PA xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;PID&gt;</SPAN>
                <SPAN LANG="en">urn:jxta:uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503</SPAN>
            <SPAN LANG="en">&amp;lt;/PID&gt;</SPAN>
            <EM><SPAN LANG="en">... remainder omitted for brevity ...</SPAN></EM>
        <SPAN LANG="en">&amp;lt;/jxta:PA&gt;</SPAN>
    <SPAN LANG="en">&lt;/PeerAdv&gt;</SPAN>
<SPAN LANG="en">&lt;/jxta:DiscoveryQuery&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-pdp-drm"></A>1.1.3.&nbsp;Discovery
Response Message</H3>
<P LANG="en">A Discovery response message is used by a peer to
respond to a discovery query message.</P>
<P LANG="en" CLASS="title"><A NAME="fdrs"></A><B>Figure&nbsp;1.2.&nbsp;Discovery
Response Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">DiscoveryResponse</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:DiscoveryResponse&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;DiscoveryResponse&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Type&quot; type=&quot;jxta:DiscoveryQueryType&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Count&quot; type=&quot;xs:unsignedInt&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Attr&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Value&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- The following should refer to a peer adv, but is instead a whole doc for historical reasons --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PeerAdv&quot; minOccurs=&quot;0&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:complexType&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:simpleContent&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:extension base=&quot;xs:string&quot;&gt;</SPAN>
         <SPAN LANG="en">&lt;xs:attribute name=&quot;Expiration&quot; type=&quot;xs:unsignedLong&quot;/&gt;</SPAN>
      <SPAN LANG="en">&lt;/xs:extension&gt;</SPAN>
      <SPAN LANG="en">&lt;/xs:simpleContent&gt;</SPAN>
      <SPAN LANG="en">&lt;/xs:complexType&gt;     </SPAN>
    <SPAN LANG="en">&lt;/xs:entry&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Response&quot; maxOccurs=&quot;unbounded&quot;&gt;</SPAN>
      <SPAN LANG="en">&lt;xs:complexType&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:simpleContent&gt;</SPAN>
          <SPAN LANG="en">&lt;xs:extension base=&quot;xs:string&quot;&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:attribute name=&quot;Expiration&quot; type=&quot;xs:unsignedLong&quot;/&gt;</SPAN>
          <SPAN LANG="en">&lt;/xs:extension&gt;</SPAN>
        <SPAN LANG="en">&lt;/xs:simpleContent&gt;</SPAN>
      <SPAN LANG="en">&lt;/xs:complexType&gt;     </SPAN>
    <SPAN LANG="en">&lt;/xs:entry&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;Type&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD>
	<SPAN LANG="en">The type of all the advertisements returned in the
	</SPAN><CODE><SPAN LANG="en">&lt;Response&gt;</SPAN></CODE><SPAN LANG="en">
	element(s). </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Count&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">If present, the number of </SPAN><CODE><SPAN LANG="en">&lt;Response&gt;</SPAN></CODE><SPAN LANG="en">
	element(s) included in this response. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;PeerAdv&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">If present, the advertisement of the respondent. The
	</SPAN><CODE><SPAN LANG="en">Expiration</SPAN></CODE><SPAN LANG="en">
	attribute is the associated relative expiration time in
	milliseconds. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Attribute&gt;</SPAN></CODE><SPAN LANG="en">,
	</SPAN><CODE><SPAN LANG="en">&lt;Value&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD>
	<SPAN LANG="en">If present, reflects that of the </SPAN><CODE><SPAN LANG="en">DiscoveryQuery</SPAN></CODE><SPAN LANG="en">
	to which this is the response. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Response&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">An advertisement.The </SPAN><CODE><SPAN LANG="en">Expiration</SPAN></CODE><SPAN LANG="en">
	attribute is the associated relative expiration time in
	milliseconds. </SPAN>
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="fdre"></A><B>Example&nbsp;1.2.&nbsp;Discovery Response</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    
<SPAN LANG="en">&lt;jxta:DiscoveryResponse&gt;</SPAN>
    <SPAN LANG="en">&lt;Type&gt;2&lt;/Type&gt;</SPAN>
    <SPAN LANG="en">&lt;Count&gt;1&lt;/Count&gt; </SPAN>
    <SPAN LANG="en">&lt;Attr&gt;Name&lt;/Attr&gt;</SPAN>
    <SPAN LANG="en">&lt;Value&gt;*sidus*&lt;/Value&gt;</SPAN>
    <SPAN LANG="en">&lt;PeerAdv&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:PA&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;jxta:PA xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;PID&gt;</SPAN>
                <SPAN LANG="en">urn:jxta:uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503</SPAN>
            <SPAN LANG="en">&amp;lt;/PID&gt;</SPAN>
            <EM><SPAN LANG="en">... omitted ...</SPAN></EM>
        <SPAN LANG="en">&amp;lt;/jxta:PA&gt;</SPAN>
    <SPAN LANG="en">&lt;/PeerAdv&gt;</SPAN>
    <SPAN LANG="en">&lt;Response Expiration=&quot;36000000&quot;&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;?xml version=&quot;1.0&quot;?&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;!DOCTYPE jxta:PipeAdvertisement&gt;</SPAN>

        <SPAN LANG="en">&amp;lt;jxta:PipeAdvertisement xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Id&gt;</SPAN>
                <SPAN LANG="en">urn:jxta:uuid-094AB61B99C14AB694D5BFD56C66E512FF7980EA1E6F4C238A26BB362B34D1F104</SPAN>
            <SPAN LANG="en">&amp;lt;/Id&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Type&gt;</SPAN>
                <SPAN LANG="en">JxtaUnicastSecure</SPAN>
            <SPAN LANG="en">&amp;lt;/Type&gt;</SPAN>
            <SPAN LANG="en">&amp;lt;Name&gt;</SPAN>
                <SPAN LANG="en">JxtaTalkUserName.sidus</SPAN>
            <SPAN LANG="en">&amp;lt;/Name&gt;</SPAN>
        <SPAN LANG="en">&amp;lt;/jxta:PipeAdvertisement&gt;</SPAN>
    <SPAN LANG="en">&lt;/Response&gt;</SPAN>
<SPAN LANG="en">&lt;/jxta:DiscoveryResponse&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-pdp-behav"></A>1.1.4.&nbsp;Behaviour</H3>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PDP</SPAN><SPAN LANG="en">
does not guarantee peers that receive a query will respond to the
query, nor does it mandate that the number of advertisements
requested will be honored. Only a best effort is made at matching the
query to results in the respondant's cache.</SPAN></P>
<P LANG="en">There is no guarantee that a response to a discovery
query request will be made. It is important to point out that
responding to a DiscoveryQuery request is optional. A peer is not
required to respond to a DiscoveryQuery request.</P>
<P><SPAN LANG="en">A reliable transport is optional with the </SPAN><SPAN LANG="en">PDP</SPAN><SPAN LANG="en">.
Multiple Discovery query messages may be sent. None, one, multiple or
redundant responses may be received.</SPAN></P>
<P LANG="en">A peer may receive a DiscoveryResponse that is not a
response to any DiscoveryQuery initiated by the peer, this mechanism
provides the ability to remote publish a resource.</P>
<P><SPAN LANG="en">The </SPAN><SPAN LANG="en">PDP</SPAN><SPAN LANG="en">
provides a mechanism for services to query the network for JXTA
resources, and receive responses. As a service, the reference
implementation helps other services by taking care of all messaging
aspects, caching, and expiring advertisements.</SPAN></P>
<P LANG="en">The actual task of propagating, and re-propagating a
query to the next set of peers is delegated to the Resolver Service.</P>
<H2 LANG="en" CLASS="title"><A NAME="proto-rvp"></A>1.2.&nbsp;Rendezvous
Protocol</H2>
<H3 LANG="en" CLASS="title"><A NAME="id301591"></A>1.2.1.&nbsp;Introduction</H3>
<P><SPAN LANG="en">The Rendezvous Protocol (</SPAN><SPAN LANG="en">RVP</SPAN><SPAN LANG="en">)
is used for propagation of messages within a peer group. The
Rendezvous Protocol provides mechanisms which enable propagation of
messages to be performed in a controlled way. To most efficiently
propagate messages some peers may agree to do extra work. Each
</SPAN><EM><A HREF="#gloss-rdv"><SPAN LANG="en">Rendezvous Peer</SPAN></A></EM><SPAN LANG="en">
cooperates with other Rendezvous Peers and with client peers to
propagate messages amongst the peers of a peer group. The Rendezvous
Peers work together to form a PeerView. The PeerView is a list of the
peers which are currently acting as Rendezvous Peers. The PeerView is
structured such that Rendezvous Peers are able to direct messages
within the peer group in a consistent way without the need for
centralized coordination.</SPAN></P>
<P LANG="en">The Rendezvous Protocol is divided into three parts; a
management protocol (PeerView), a connection registration protocol
and the protocol used for transmiting propagated messages.</P>
<P LANG="en">The PeerView protocol is an optional protocol used by
Rendezvous Peers to organize themselves. The PeerView protocol is
used to form and verify the integrity of the PeerView. Each
Rendezvous Peer maintains its own local list of active PeerView
members. Rendezvous Peers exchange PeerView messages with the other
PeerView members to maintain their local PeerView.</P>
<P LANG="en">The Rendezvous Lease Protocol is an optional protocol
which enables non-Rendezvous Peers to subscribe to receive propagated
messages. Rendezvous Peers offer leases to subscribing peers based
upon the Rendezvous Peer's ability to distribute propagated messages.
During the term of the offered lease the Rendezvous Peer will accept
messages from the subscribing peer for propagation to the peer group
and will distribute any appropriate propagation messages to the
subscriber. Both the Rendezvous Peer and the subscriber peer may
terminate the lease at any time.</P>
<P LANG="en">The Rendezvous Propagation Protocol is the only required
protocol for peers which use the Rendezvous Service. The Rendezvous
Propagation Protocol enables peers to manage the propagation of
individual messages within a peer group. The Rendezvous Propagation
Protocol enables peers to determine the source of a propagated
message, the peers the message has already traversed, the listener
name to which the message is addressed and the remaining distance
which the message may travel before expiring.</P>
<H3 LANG="en" CLASS="title"><A NAME="advert-rdv"></A>1.2.2.&nbsp;Rendezvous
Advertisement</H3>
<P LANG="en">A Rendezvous advertisement describes a peer that acts as
a Rendezvous Peer for a given PeerGroup. Those advertisements can be
published and retrieved, so peers that are looking for rendezvous
peers can find them.</P>
<P LANG="en" CLASS="title"><A NAME="fras"></A><B>Figure&nbsp;1.3.&nbsp;Rendezvous
Advertisement Schema</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:element name=&quot;RdvAdvertisement&quot; type=&quot;jxta:RdvAdvertisement&quot;/&gt;

<SPAN LANG="en">&lt;xs:complexType name=&quot;RdvAdvertisement&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;RdvGroupId&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;RdvPeerId&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;RdvServiceName&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Name&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;RdvRoute&quot; type=&quot;jxta:RA&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;RdvGroupId&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	This is a required element that contains the ID of the PeerGroup for
	which the peer is a rendezvous. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;RdvPeerId&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	This is a required element that contains the ID of the peer which is
	a rendezvous. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;RdvServiceName&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	This is a required element that identifies the PeerView to which the
	Rendezvous Peer belongs. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Name&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	This is an optional name associated with the rendezvous peer. Often
	the same as the peer name. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;RdvRoute&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">An optional route to the Rendezvous Peer. A <A HREF="#feprra">Route
	Advertisement</A> is included as a child of the </SPAN><CODE><SPAN LANG="en">&lt;RdvRoute&gt;</SPAN></CODE><SPAN LANG="en">
	element. </SPAN>
	</DD></DL>
<H3 LANG="en" CLASS="title">
<A NAME="id301838"></A>1.2.3.&nbsp;PeerView Protocol</H3>
<P LANG="en">The PeerView Protocol is used by Rendezvous Peers to
organize orderly interactions amongst themselves. The PeerView is a
collection of the participant peers. The collection of all RendezVous
Peers within a peer group is the Rendezvous PeerView. The state of
the peer group's PeerView is not maintained on a specific peer.
Instead, each Rendezvous Peer maintains a local version of its view
of the global PeerView. Each local version is loosely consistent with
all other local versions. The goal of the PeerView Protocol is to
create and maintain a consistent Peerview state.</P>
<P><SPAN LANG="en">The PeerView participants exchange messages with
other PeerView participants. Each PeerView message contains a
<A HREF="#advert-rdv">Rendezvous Advertisement</A> and is either a
probe or response message. Probe messages contain the Rendezvous
Advertisement for the peer which initiates the probe. PeerView
response messages may contain the Rendezvous Advertisement of the
responding peer or Rendezvous Advertisement of another peer.
Responses containing advertisements for other than the responding
peer is how Rendezvous Peers learn of other PeerView members.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="fpvm"></A><B>Figure&nbsp;1.4.&nbsp;PeerView
Message</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Edge Peer Flag Element (optional)</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Message Element Namespace</P>
			</TD>
			<TD>
				<P><CODE>jxta</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Message Element Name</P>
			</TD>
			<TD>
				<P><CODE>PeerView.EdgePeer</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Mime Media Type</P>
			</TD>
			<TD>
				<P><CODE>text/plain; charset=UTF-8</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Element Content</P>
			</TD>
			<TD>
				<P><CODE>true</CODE></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Cached Flag Element (optional)</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Message Element Namespace</P>
			</TD>
			<TD>
				<P><CODE>jxta</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Message Element Name</P>
			</TD>
			<TD>
				<P><CODE>PeerView.Cached</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Mime Media Type</P>
			</TD>
			<TD>
				<P><CODE>text/plain; charset=UTF-8</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Element Content</P>
			</TD>
			<TD>
				<P><CODE>true</CODE></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Failure Notification Flag Element (optional)</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Message Element Namespace</P>
			</TD>
			<TD>
				<P><CODE>jxta</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Message Element Name</P>
			</TD>
			<TD>
				<P><CODE>PeerView.Failure</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Mime Media Type</P>
			</TD>
			<TD>
				<P><CODE>text/plain; charset=UTF-8</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Element Content</P>
			</TD>
			<TD>
				<P><CODE>true</CODE></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Probe Element (optional)</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Message Element Namespace</P>
			</TD>
			<TD>
				<P><CODE>jxta</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Message Element Name</P>
			</TD>
			<TD>
				<P><CODE>PeerView.PeerAdv</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Mime Media Type</P>
			</TD>
			<TD>
				<P><CODE>text/xml; charset=UTF-8</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Element Content</P>
			</TD>
			<TD>
				<P>RdvAdvertisement of the Probing Peer.</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Response Element (optional)</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Message Element Namespace</P>
			</TD>
			<TD>
				<P><CODE>jxta</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Message Element Name</P>
			</TD>
			<TD>
				<P><CODE>PeerView.PeerAdv.Response</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Mime Media Type</P>
			</TD>
			<TD>
				<P><CODE>text/xml; charset=UTF-8</CODE></P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Element Content</P>
			</TD>
			<TD>
				<P>RdvAdvertisement of the Responding Peer.</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P><BR><BR>
</P>
<P LANG="en">The same basic PeerView Message is used for all PeerView
interations. The core of the PeerView Message is either the probe or
response element. Probe messages normally result in a response
message from the receiving peer. Response messages normally receive
no response. The PeerView Message elements other than the probe or
response serve as annotations upon the basic message.</P>
<P LANG="en" CLASS="title"><A NAME="fpvms"></A><B>Figure&nbsp;1.5.&nbsp;PeerView
Message Scenarios</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Edge Probe</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Purpose</P>
			</TD>
			<TD>
				<P>A probe message by a peer which is not a participant in the
				PeerView to learn of PeerView participants. The Rendezvous
				Advertisement included is provided to enable the receiver to
				respond. It is not actually an advertisement for a Rendezvous
				Peer. The response should be a PeerView Message containing the
				Rendezvous Advertisement of random PeerView participant.</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Elements</P>
			</TD>
			<TD>
				<P>EDGE, PROBE</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Sent via</P>
			</TD>
			<TD>
				<P>Pipe</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Participant Probe</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Purpose</P>
			</TD>
			<TD>
				<P>A probe message by a participant peer to another PeerView
				participant. Response should be a PeerView Message containing the
				Rendezvous Advertisement of the responding peer. Additionally, a
				second response containing the Rendezvous Advertisement of a
				random PeerView participant may also be sent to the probing peer.</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Elements</P>
			</TD>
			<TD>
				<P>PROBE</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Sent via</P>
			</TD>
			<TD>
				<P>Endpoint Listener</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Participant Response</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Purpose</P>
			</TD>
			<TD>
				<P>A response message by a participant peer to another PeerView
				participant. The response Rendezvous Advertisement must be that
				of the responding peer.</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Elements</P>
			</TD>
			<TD>
				<P>RESPONSE</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Participant Referral Response</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Purpose</P>
			</TD>
			<TD>
				<P>A response message by one PeerView participant peer to another
				participant peer providing a refferal to another different
				participant peer. The response Rendezvous Advertisement must be
				that a participant peer which is neither the responding peer nor
				the intended recipient peer.</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Elements</P>
			</TD>
			<TD>
				<P>CACHED, RESPONSE</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Sent via</P>
			</TD>
			<TD>
				<P>Endpoint Listener</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Shutdown Notification</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Purpose</P>
			</TD>
			<TD>
				<P>A response message by a participant peer providing
				notification that the responding peer is shutting down and will
				no longer be available. This is a courtesy message which enables
				the other participant peers to more quickly update their local
				views.</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Elements</P>
			</TD>
			<TD>
				<P>FAILURE, RESPONSE</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Sent via</P>
			</TD>
			<TD>
				<P>Pipe</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH COLSPAN=2>
				<P ALIGN=LEFT>Failure Notification</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TD>
				<P>Purpose</P>
			</TD>
			<TD>
				<P>A response message by a participant peer providing
				notification that the identified peer has failed and is no longer
				be available. This is a courtesy message which enables the other
				participant peers to more quickly update their local views.</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Elements</P>
			</TD>
			<TD>
				<P>CACHED, FAILURE, RESPONSE</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>Sent via</P>
			</TD>
			<TD>
				<P>Pipe</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="id302742"></A>1.2.4.&nbsp;Rendezvous
Lease Protocol</H3>
<P LANG="en">The Rendezous Lease Protocol is an optional that allows
non-Rendezvous Peers to subscribe to receive propagated messages. The
subscriber peers requests a lease of a Rendezvous Peer and may
receive a lease in response. Leases are of fixed duration. During the
term of the lease the Rendezvous Peer will accept messages from the
subscriber peer for propagation to the peer group and will send to
the subscriber peer propgated messages received from the peer group.</P>
<H4 LANG="en" CLASS="title"><A NAME="id302765"></A>1.2.4.1.&nbsp;Lease
Request Message</H4>
<P LANG="en">When a peer wants to connect to a Rendezvous Peer, it
sends a message with the a message element named jxta:Connect which
contains its Peer advertisement.</P>
<H4 LANG="en" CLASS="title"><A NAME="id302776"></A>1.2.4.2.&nbsp;Lease
Granted Message</H4>
<P LANG="en">When a rendezvous peer grants a lease (upon a lease
request), it sends a message to the source of the lease request,
containing the following message elements:</P>
<DL>
	<DT LANG="en">jxta:ConnectedLease 
	</DT><DD LANG="en">
	This message element contains (in a String representation) the time
	in milliseconds the lease is granted for. This message element is
	mandatory. 
	</DD><DT LANG="en">
	jxta:ConnectedPeer 
	</DT><DD LANG="en">
	This message element contains the PeerID of the rendezvous peer that
	has granted the lease. This message element is mandatory. 
	</DD><DT LANG="en">
	jxta:RdvAdvReply 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	This message element contains the Peer Advertisement of the
	rendezvous peer that grants the lease. This message element is
	optional. 
	</DD></DL>
<H4 LANG="en" CLASS="title">
<A NAME="id302826"></A>1.2.4.3.&nbsp;Lease Cancel Message</H4>
<P LANG="en">When a peer wants to cancel a lease, it sends a message
with the following message element:</P>
<UL TYPE=DISC>
	<LI><P LANG="en">&quot;jxta:Disconnect&quot;: This message element
	contains the Peer Advertisement of the peer which is requesting to
	cancel the lease. This message element is mandatory. 
	</P>
</UL>
<H3 LANG="en" CLASS="title"><A NAME="id302845"></A>1.2.5.&nbsp;Message
Propagation Protocol</H3>
<H3 LANG="en" CLASS="title"><A NAME="id302853"></A>1.2.6.&nbsp;Behaviour</H3>
<H4 LANG="en" CLASS="title"><A NAME="id302858"></A>1.2.6.1.&nbsp;Peer
connection</H4>
<P LANG="en">Rendezvous peers which re-propagate messages they have
received. A peer can dynamically become a rendezvous peer or may
connect to a rendezvous peer. The connection between a peer and a
rendezvous peer is achieved by an explicit connection, associated to
a lease.</P>
<P LANG="en">This connection is performed by sending messages using
the JXTA Endpoint Protocol. Each peer implementing the Rendezvous
protocol must register with the Endpoint Service to receive messages
with the following Service Name and Service Param:</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">service name:
	JxtaPropagate 
	</P>
	<LI><P LANG="en">service param: PeerGroup ID 
	</P>
</UL>
<P LANG="en">A set of queries and responses are defined by the
Rendezvous Protocol in order to establish connections:</P>
<UL TYPE=DISC>
	<LI><P STYLE="margin-bottom: 0cm"><EM><SPAN LANG="en">LeaseRequest</SPAN></EM><SPAN LANG="en">
	This request is sent by a peer that desires to connect to a given
	rendezvous. A lease may always be canceled by either party at
	anytime if necessary. A rendezvous that grants a lease returns
	LeaseGranted. </SPAN>
	</P>
	<LI><P><EM><SPAN LANG="en">LeaseGranted</SPAN></EM><SPAN LANG="en">
	This message is sent by a rendezvous to grant a lease to a given
	client. The amount of time the lease is granted for is included in
	the message. </SPAN>
	</P>
</UL>
<H4 LANG="en" CLASS="title"><A NAME="id302930"></A>1.2.6.2.&nbsp;Propagation
Control</H4>
<P LANG="en">The Rendezvous Protocol implementation is responsible
for controlling the propagation of messages. A Rendezvous Service
should propagate a message unless of the following conditions is
detected:</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Loop: if a propagated
	messages has already been processed on a peer, it is discarded. 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">TTL: propagated messages
	are associated with a Time To Live (TTL). Each time a propagated
	message is received on a peer, its TTL is decreased by one. When the
	TTL of a message drops to zero, the message is discarded. 
	</P>
	<LI><P LANG="en">Duplicate: each propagated message is associated
	with a unique identifier. When a propagated message has been
	duplicated, and has already been received on a peer, duplicates are
	discarded. 
	</P>
</UL>
<P LANG="en">This control is performed by embedding a Message Element
within each propagated message that is defined as:</P>
<P LANG="en" CLASS="title"><A NAME="frpms"></A><B>Figure&nbsp;1.6.&nbsp;RendezVous
Propagate Message Schema</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:element name=&quot;RendezVousPropagateMessage&quot; type=&quot;jxta:RendezVousPropagateMessage&quot;/&gt;
<SPAN LANG="en">&lt;xs:complexType name=&quot;RendezVousPropagateMessage&quot;&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:element name=&quot;MessageId&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
            <SPAN LANG="en">&lt;!-- This should be a constrained subtype --&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:element name=&quot;DestSName&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:element name=&quot;DestSParam&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:element name=&quot;TTL&quot; type=&quot;xs:unsignedInt&quot; /&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:element name=&quot;Path&quot; type=&quot;jxta:JXTAID&quot; maxOccurs=&quot;unbounded&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H2 LANG="en" CLASS="title"><A NAME="proto-pip"></A>1.3.&nbsp;Peer
Information Protocol</H2>
<P LANG="en">Once a peer is located, its capabilities and status may
be queried. PIP provides a set of messages to obtain a peer status
information. PIP is an optional JXTA protocol. Peers are not required
to respond to PIP requests.</P>
<P LANG="en">A reliable transport is optional for PIP. Multiple peer
information messages may be sent. None, one or multiple responses may
be received in response to any query.</P>
<P><SPAN LANG="en">The PIP is layered upon the <A HREF="#proto-prp">Peer
Resolver Protocol</A>. The </SPAN><CODE><SPAN LANG="en">&lt;QueryID&gt;</SPAN></CODE><SPAN LANG="en">
element is used to match PIP queries containing </SPAN><CODE><SPAN LANG="en">&lt;request&gt;</SPAN></CODE><SPAN LANG="en">
elements to the PIP Response Messages containing the matching
responses.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="proto-pip-mops"></A>1.3.1.&nbsp;Obtaining
PIP Responses</H3>
<P><SPAN LANG="en">The PIP Query Message provides a </SPAN><EM><SPAN LANG="en">request</SPAN></EM><SPAN LANG="en">
field that may be used to encode a specific request. PIP does not
dictate the format of the </SPAN><EM><SPAN LANG="en">request</SPAN></EM><SPAN LANG="en">
field and it is left up to the consumer to do so. Higher-level
services may utilize the request field to offer expanded
capabilities.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="proto-pip-query"></A>1.3.2.&nbsp;PIP
Query Message</H3>
<P LANG="en">The query message is sent to a peer to query the current
state of the peer, and obtain other relevant information about the
peer. A query without a defined request field returns a default set
of information about a peer (i.e. uptime, message count, etc.).</P>
<P LANG="en" CLASS="title"><A NAME="fpipqs"></A><B>Figure&nbsp;1.7.&nbsp;PIP
Query Message</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:element name=&quot;PeerInfoQueryMessage&quot; type=&quot;jxta:PeerInfoQueryMessage&quot;/&gt;

<SPAN LANG="en">&lt;xs:complexType name=&quot;PeerInfoQueryMessage&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;sourcePid&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;targetPid&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;!-- if not present then the response is the general peerinfo --&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;request&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;sourcePid&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The peer id of the requesting peer. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;targetPid&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The peer id of the peer being queried. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;request&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	An optional Request structure. 
	</DD></DL>
<H3 LANG="en" CLASS="title">
<A NAME="proto-pip-response"></A>1.3.3.&nbsp;PIP Response Message</H3>
<P LANG="en">The Peer Information Protocol Response Message provides
specific information about the current state of a peer, such as
uptime, inbound and outbound message count, time last message
received, and time last message sent.</P>
<P LANG="en" CLASS="title"><A NAME="fpiprs"></A><B>Figure&nbsp;1.8.&nbsp;PIP
Response Message</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:element name=&quot;PeerInfoResponseMessage&quot; type=&quot;jxta:PeerInfoResponseMessage&quot;/&gt;

<SPAN LANG="en">&lt;xs:complexType name=&quot;PeerInfoResponseMessage&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;sourcePid&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;targetPid&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;uptime&quot; type=&quot;xs:unsignedLong&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;timestamp&quot; type=&quot;xs:unsignedLong&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;response&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;traffic&quot; type=&quot;jxta:piptraffic&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;piptraffic&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;lastIncomingMessageAt&quot; type=&quot;xs:unsignedLong&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;lastOutgoingMessageAt&quot; type=&quot;xs:unsignedLong&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;in&quot; type=&quot;jxta:piptrafficinfo&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;out&quot; type=&quot;jxta:piptrafficinfo&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;piptrafficinfo&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;transport&quot; maxOccurs=&quot;unbounded&quot;&gt;</SPAN>
            <SPAN LANG="en">&lt;xs:complexType&gt;</SPAN>
                <SPAN LANG="en">&lt;xs:simpleContent&gt;</SPAN>
                    <SPAN LANG="en">&lt;xs:extension base=&quot;xs:unsignedLong&quot;&gt;</SPAN>
                        <SPAN LANG="en">&lt;xs:attribute name=&quot;Expiration&quot; type=&quot;xs:anyURI&quot; /&gt;</SPAN>
                    <SPAN LANG="en">&lt;/xs:extension&gt;</SPAN>
                <SPAN LANG="en">&lt;/xs:simpleContent&gt;</SPAN>
            <SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN>
        <SPAN LANG="en">&lt;/xs:element&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;sourcePid&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The peer id of the requesting peer. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;targetPid&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The peer id of the peer being queried. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;uptime&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The relative time in milliseconds since the responding Peer
	Information Service began execution. Peers should provide this tag
	in all responses, but may chose to not implement it if the
	information is unavailable or would represent a security breach. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;timestamp&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The absolute time at which this response was generated. Measured in
	milliseconds since &quot;the epoch&quot;, namely January 1, 1970,
	00:00:00 GMT. Peers should provide this tag in all responses, but
	may chose to not implement it if the information is unavailable or
	would represent a security breach. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;response&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD>
	<SPAN LANG="en">Potentially contains a response to a previous
	request from a PIP Query. To match queries to responses the </SPAN><EM><SPAN LANG="en">QueryId</SPAN></EM><SPAN LANG="en">
	element of the <A HREF="#proto-prp">Peer Resolver Protocol</A> must
	match. This field can contain any desired content. </SPAN>
	</DD><DT STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">&lt;traffic&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Contains information about the network traffic performed by the
	target peer. This element is optional.</DD><DL>
		<DT>
		<CODE><SPAN LANG="en">&lt;lastIncomingMessageAt&gt;</SPAN></CODE><SPAN LANG="en">
		</SPAN>
		</DT><DD LANG="en">
		The absolute time at which this peer last received a valid JXTA
		message on one of its transports. Measured in milliseconds since
		&quot;the epoch&quot;, namely January 1, 1970, 00:00:00 GMT. Peers
		should provide this tag in all responses, but may chose to not
		implement it if the information is unavailable or would represent a
		security breach. 
		</DD><DT>
		<CODE><SPAN LANG="en">&lt;lastOutgoingMessageAt&gt;</SPAN></CODE><SPAN LANG="en">
		</SPAN>
		</DT><DD LANG="en">
		The absolute time at which this peer last sent a valid JXTA message
		on one of its transports. Measured in milliseconds since &quot;the
		epoch&quot;, namely January 1, 1970, 00:00:00 GMT. Peers should
		provide this tag in all responses, but may chose to not implement
		it if the information is unavailable or would represent a security
		breach. 
		</DD><DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">&lt;in&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		If present, contains elements which describe incoming traffic from
		various endpoint addresses.</DD><DL>
			<DT STYLE="text-align: justify">
			<CODE><FONT COLOR="#000000"><SPAN LANG="en">&lt;transport&gt;</SPAN></FONT></CODE><FONT COLOR="#000000"><SPAN LANG="en">
			</SPAN></FONT>
			</DT><DD LANG="en" STYLE="text-align: justify">
			Provides the number of bytes received by the named endpoint
			address. 
			</DD></DL>
		<DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">&lt;out&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		If present, contains elements which describe outgoing traffic from
		various endpoint addresses.</DD><DL>
			<DT STYLE="text-align: justify">
			<CODE><FONT COLOR="#000000"><SPAN LANG="en">&lt;transport&gt;</SPAN></FONT></CODE><FONT COLOR="#000000"><SPAN LANG="en">
			</SPAN></FONT>
			</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm; text-align: justify">
			Provides the number of bytes transmitted by the named endpoint
			address. 
			</DD></DL>
	</DL>
</DL>
<H2 LANG="en" CLASS="title">
<A NAME="proto-pbp"></A>1.4.&nbsp;Pipe Binding Protocol</H2>
<P><SPAN LANG="en">The Pipe Binding Protocol (</SPAN><SPAN LANG="en">PBP</SPAN><SPAN LANG="en">)
is used by applications and services in order to communicate with
other peers. A pipe is a virtual channel between two endpoints
described in a Pipe Advertisement. There are two ends of a Pipe: the
Input Pipe (receiving end) and the Output Pipe (sending end).</SPAN></P>
<P LANG="en">The Pipe Binding Protocol is layered upon the Endpoint
Protocol, and will use a variety of Message Transports such as the
JXTA HTTP Transport, the JXTA TCP/IP Transport, or the secure JXTA
TLS Transport for the sending of messages.</P>
<P LANG="en">A pipe can be viewed as an abstract named message queue,
supporting create, open/resolve (bind), close (unbind), delete, send,
and receive operations. Actual pipe implementations may differ, but
all compliant implementations use the PBP to bind the pipe to an
endpoint.</P>
<P LANG="en">A reliable message transport is optional. Multiple
binding query messages may be sent. None, one or multiple responses
may be received.</P>
<H3 LANG="en" CLASS="title"><A NAME="advert-pia"></A>1.4.1.&nbsp;Pipe
Advertisement</H3>
<P LANG="en">A Pipe Advertisement describes a pipe. The pipe
advertisement is used by the pipe service to create associated local
input and output pipe endpoints.</P>
<P LANG="en">Each pipe advertisement includes a Pipe ID which is the
canonical name for the pipe.</P>
<P LANG="en">Each pipe advertisement must include a pipe type.There
are currently three different types of pipes:</P>
<UL TYPE=DISC>
	<LI><P STYLE="margin-bottom: 0cm"><CODE><SPAN LANG="en">JxtaUnicast</SPAN></CODE><SPAN LANG="en">
	Unicast, unsecure and unreliable. This type of pipe is used to send
	one-to-one messages. </SPAN>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><CODE><SPAN LANG="en">JxtaUnicastSecure</SPAN></CODE><SPAN LANG="en">
	Unicast, secure (using TLS). An extension of the </SPAN><CODE><SPAN LANG="en">JxtaUnicast</SPAN></CODE><SPAN LANG="en">,
	except that the data is protected using a virtual TLS connection
	between the endpoints. </SPAN>
	</P>
	<LI><P><CODE><SPAN LANG="en">JxtaPropagate</SPAN></CODE><SPAN LANG="en">
	Diffusion pipes. This pipe type is used to send one-to-many
	messages. Any peer that has enabled an Input Pipe on a propagate
	type pipe receives messages that are sent onto it. </SPAN>
	</P>
</UL>
<P LANG="en">A pipe advertisement may include an optional symbolic
name.</P>
<P LANG="en" CLASS="title"><A NAME="fpipeas"></A><B>Figure&nbsp;1.9.&nbsp;Pipe
Advertisement Schema</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;xs:element name=&quot;PipeAdvertisment&quot; type=&quot;jxta:PipeAdvertisment&quot;/&gt;

<SPAN LANG="en">&lt;xs:complexType name=&quot;PipeAdvertisement&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Id&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Type&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Name&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
        <SPAN LANG="en">&lt;xs:element name=&quot;Desc&quot; type=&quot;xs:anyType&quot; minOccurs=&quot;0&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;Id&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">This is a required element that uniquely identifies
	the pipe. Each pipe has a unique id. See <A HREF="#ids">IDs</A> for
	description of JXTA Ids. </SPAN>
	</DD><DT STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">&lt;Type&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	This is an required element that defines the type of the pipe. The
	following types are currently defined:</DD><DL>
		<DT>
		<CODE><SPAN LANG="en">JxtaUnicast</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		may not arrive at the destination, may be delivered more than once
		to the same destination, may arrive in different order. 
		</DD><DT>
		<CODE><SPAN LANG="en">JxtaUnicastSecure</SPAN></CODE><SPAN LANG="en">
		</SPAN>
		</DT><DD LANG="en">
		may not arrive at the destination, may be delivered more than once
		to the same destination, may arrive in different order, but is
		encrypted using TLS. 
		</DD><DT>
		<CODE><SPAN LANG="en">JxtaPropagate</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		one to many pipe. 
		</DD></DL>
	<DT>
	<CODE><SPAN LANG="en">&lt;Name&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	This is an optional name that can be associated with a pipe. The
	name is not required to be unique unless the name is obtained from a
	centralized naming service that guarantee name uniqueness. 
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="fpipeae"></A><B>Example&nbsp;1.3.&nbsp;Pipe Advertisement</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

<SPAN LANG="en">&lt;!DOCTYPE jxta:PipeAdvertisement&gt;</SPAN>

<SPAN LANG="en">&lt;jxta:PipeAdvertisement xmlns:jxta=&quot;http://jxta.org&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;Id&gt;urn:jxta:uuid-094AB61B99C14AB694D5BFD56C66E512FF7980EA1E6F4C238A26BB362B34D1F104&lt;/Id&gt; </SPAN>
  <SPAN LANG="en">&lt;Type&gt;JxtaUnicast&lt;/Type&gt; </SPAN>
  <SPAN LANG="en">&lt;Name&gt;Talk to Me!&lt;/Name&gt;</SPAN>
<SPAN LANG="en">&lt;/jxta:PipeAdvertisement&gt;</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="proto-pbp-prm"></A>1.4.2.&nbsp;Pipe
Resolver Message</H3>
<P><SPAN LANG="en">For some pipe types, notably </SPAN><CODE><SPAN LANG="en">JxtaUnicast</SPAN></CODE><SPAN LANG="en">
and </SPAN><CODE><SPAN LANG="en">JxtaUnicastSecure</SPAN></CODE><SPAN LANG="en">
it is necessary to locate a peer which is listening on the pipe in
order to create an Output Pipe. For these pipe types the Pipe Service
uses the &quot;Pipe Resolver Message&quot;. The same message schema
is used for both the resolve query and for the response.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="fprms"></A><B>Figure&nbsp;1.10.&nbsp;Pipe
Resolver Message Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">PipeResolver</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:PipeResolver&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:simpleType name=&quot;PipeResolverMsgType&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:restriction base=&quot;xs:string&quot;&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- QUERY --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:enumeration value=&quot;Query&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- ANSWER --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:enumeration value=&quot;Answer&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:restriction&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:simpleType&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;PipeResolver&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MsgType&quot; type=&quot;jxta:PipeResolverMsgType&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PipeId&quot; type=&quot;jxta:JXTAID&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Type&quot; type=&quot;xs:string&quot;/&gt;</SPAN>

    <SPAN LANG="en">&lt;!-- used in the query --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Cached&quot; minOccurs=&quot;0&quot; default=&quot;true&quot; type=&quot;xs:boolean&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Peer&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>

    <SPAN LANG="en">&lt;!-- used in the answer --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;Found&quot; minOccurs=&quot;0&quot; type=&quot;xs:boolean&quot;/&gt;</SPAN>
    <SPAN LANG="en">&lt;!-- This should refer to a peer adv, but is instead a whole doc --&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PeerAdv&quot; minOccurs=&quot;0&quot; type=&quot;xs:string&quot;/&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;         </SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT STYLE="margin-bottom: 0.5cm"><CODE><SPAN LANG="en">&lt;MsgType&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Used to indicate if it is the Query or the Answer. May be one of:</DD><DL>
		<DT>
		<CODE><SPAN LANG="en">Query</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		This is a query. 
		</DD><DT>
		<CODE><SPAN LANG="en">Answer</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en">
		This is a response. 
		</DD></DL>
	<DT>
	<CODE><SPAN LANG="en">&lt;PipeId&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The Pipe ID which is being resolved. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Type&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">The type of pipe resolution being requested. This
	value must match the value of </SPAN><CODE><SPAN LANG="en">&lt;Type&gt;</SPAN></CODE><SPAN LANG="en">
	from the Pipe Advertisement. </SPAN>
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;Cached&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD>
	<SPAN LANG="en">If </SPAN><CODE><SPAN LANG="en">false</SPAN></CODE><SPAN LANG="en">,
	peers which do not have the pipe bound locally as an Input Pipe must
	not respond to the query. They may forward the query to peers which
	they believe to have the pipe bound as an Input Pipe. This feature
	is deprecated and implementations should treat the tag as always
	being </SPAN><CODE><SPAN LANG="en">false</SPAN></CODE><SPAN LANG="en">.
	</SPAN>
	</DD><DT STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">&lt;Peer&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A peer id. In Queries, if present, it specifies the Peer ID of the
	only peer from which responses will be expected. Responses from all
	other peers may be ignored. This does not guarantee a response to
	the pipe binding request will be made by the peer. Response to pipe
	binding requests is always optional.</DD><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	In Answer messages, all of the peers on which the Input Pipe is
	known to be bound.</DD><DT>
	<CODE><SPAN LANG="en">&lt;Found&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Used to indicate if the Input Pipe was found on the specified peer. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;PeerAdv&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Peer Advertisement of the peer which resolved the Input Pipe. This
	peer may appear in the list of peer ids on which the Input Pipe is
	bound, but this should not be assumed. 
	</DD></DL>
<H3 LANG="en" CLASS="title">
<A NAME="proto-pbp-wh"></A>1.4.3.&nbsp;Propagate Pipe Message Header</H3>
<P><SPAN LANG="en">Every message sent on a propagate pipe includes a
message element which is used to manage the propragation of messages.
The message element is stored in the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace and has the name </SPAN><CODE><SPAN LANG="en">JxtaWireHeader</SPAN></CODE><SPAN LANG="en">.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="fwhms"></A><B>Figure&nbsp;1.11.&nbsp;Propagate
Pipe Message Header Schema</B></P>
<PRE CLASS="programlisting"><SPAN LANG="en">&lt;xs:element name=&quot;</SPAN><CODE><SPAN LANG="en">JxtaWire</SPAN></CODE><SPAN LANG="en">&quot; type=&quot;jxta:JxtaWire&quot;/&gt;</SPAN>

<SPAN LANG="en">&lt;xs:complexType name=&quot;jxta:JxtaWire&quot;&gt;</SPAN>
  <SPAN LANG="en">&lt;xs:sequence&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;SrcPeer&quot; minOccurs=&quot;0&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;PipeId&quot; type=&quot;jxta:JXTAID&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;MsgId&quot; type=&quot;xs:string&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;TTL&quot; type=&quot;xs:unsignedInt&quot; /&gt;</SPAN>
    <SPAN LANG="en">&lt;xs:element name=&quot;VisitedPeer&quot; type=&quot;jxta:JXTAID&quot;  maxOccurs=&quot;unbounded&quot; /&gt;</SPAN>
  <SPAN LANG="en">&lt;/xs:sequence&gt;</SPAN>
<SPAN LANG="en">&lt;/xs:complexType&gt;</SPAN></PRE><P>
<BR><BR>
</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;SrcPeer&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The peer which originated this message. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;PipeId&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	The ID of the pipe on which the message is being sent. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;MsgId&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Each message has an associated token which is used for duplicate
	tracking. This token is normally generated using a pseudo random
	source or partially pseudo randomly in order to reduce the chance of
	collisions. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;TTL&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD LANG="en">
	Each peer attempting to forward this message should first decrement
	the TTL value. If the value reaches zero then the message should not
	be forwarded to any additional peers. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;VisitedPeer&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The set of peers which are known to have seen this message. Peers
	which forward propagate pipe messages should add themselves to this
	list before forwarding the message. They should also avoid
	forwarding the message to any of the peers listed. 
	</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="stdsvc-trans"></A>Chapter&nbsp;2.&nbsp;Standard JXTA Message
Transports</H2>
<P LANG="en">JXTA defines several Message Transport Bindings for
implementing JXTA messaging on top of existing networks.</P>
<H2 LANG="en" CLASS="title"><A NAME="trans-tcpipt"></A>2.1.&nbsp;TCP/IP
Message Transport</H2>
<H3 LANG="en" CLASS="title"><A NAME="trans-ipt-tcpipinto"></A>2.1.1.&nbsp;Introduction</H3>
<P><SPAN LANG="en">This section describes the TCP/IP Message
Transport, the most commonly used Message Transport by JXTA. It is
named the TCP/IP binding because it uses no other underlying
protocols whereas other Message Transports build upon, for example,
the HTTP <A HREF="#bib-RFC2616">RFC2616</A>, TLS <A HREF="#bib-RFC2246">RFC2246</A>,
BEEP <A HREF="#bib-RFC3080">RFC3080</A> <A HREF="#bib-RFC3081">RFC3081</A>
and SMTP <A HREF="#bib-RFC821">RFC821</A> protocols. The TCP/IP
transport is designed to be the simplest and quickest to implement of
the JXTA Message Transport bindings. Unfortunately, the TCP/IP
Message Transport can be adversely affected by the partitioning of
the Internet Address Space caused by Network Address Translation
(NAT), Firewalls, and conflicting use of Private IP Address ranges.
For these circumstances one of the other Message Transports may be
more effcient.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="trans-ipt-tcpipchoreo"></A>2.1.2.&nbsp;Choreography</H3>
<P LANG="en">This section describes the protocol exchange implemented
by the JXTA TCP/IP Message Transport. The two participants operate
symmetrically, the message sequence is the same for both sides.</P>
<UL TYPE=DISC>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Connection Opens 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Welcome Message 
	</P>
	<LI><P LANG="en" STYLE="margin-bottom: 0cm">Message(s) 
	</P>
	<LI><P LANG="en">Connection Closes 
	</P>
</UL>
<P LANG="en">The connection may be closed by either peer following
the transmission of any number of messages. If a peer discover an
error in the transmission ( unexpected input, unsupported message
content, framing problems, etc. ) it must close the connection.</P>
<H3 LANG="en" CLASS="title"><A NAME="trans-ipt-tcpipwm"></A>2.1.3.&nbsp;Welcome
Message</H3>
<P LANG="en">The Welcome Message is sent by both peers of a JXTA
TCP/IP Communication. It's primary purpose is to identify the
endpoint address that each peer has associated with TCP/IP
connections on that interface/port. Additionally, the welcome message
provides a reasonable &ldquo;ping&rdquo; response if the only goal of
the connection is to determine connectivity.</P>
<P LANG="en">A peer should send its Welcome Message as soon as the
connection is opened, but must not send any Message Bodies until it
has received a Welcome Message from the remote peer. A peer must send
its peer id as the connection endpoint address. The welcome message
can be no longer than 4096 octets in length, though in practice it
will almost always be much shorter.</P>
<P LANG="en" CLASS="title"><A NAME="id307872"></A><B>Figure&nbsp;2.1.&nbsp;Welcome
Message ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;WELCOME&gt;      ::= &lt;GREETING&gt; &lt;SPACE&gt; &lt;WELCOMEDEST&gt; &lt;SPACE&gt; 
                   <SPAN LANG="en">&lt;WELCOMESRC&gt; &lt;SPACE&gt; &lt;WELCOMEPEER&gt; &lt;SPACE&gt;</SPAN>
                   <SPAN LANG="en">&lt;NOPROP&gt; &lt;SPACE&gt; &lt;VERSION&gt; &lt;CRLF&gt;</SPAN>

<SPAN LANG="en">&lt;GREETING&gt;     ::= &quot;JXTAHELLO&quot;</SPAN>

<SPAN LANG="en">&lt;SPACE&gt;        ::=  octect #x20</SPAN>

<SPAN LANG="en">&lt;WELCOMEDEST&gt;  ::=  &lt;ENDPOINTADDRESS&gt; </SPAN>

<SPAN LANG="en">&lt;WELCOMEADDR&gt;  ::= &lt;ENDPOINTADDRESS&gt;</SPAN>

<SPAN LANG="en">&lt;WELCOMEPEER&gt;  ::=  &lt;JXTAID&gt; </SPAN>

<SPAN LANG="en">&lt;NOPROP&gt;       ::=  &quot;0&quot; | &quot;1&quot;</SPAN>

<SPAN LANG="en">&lt;VERSION&gt;      ::=  &quot;1.1&quot;</SPAN>

<SPAN LANG="en">&lt;CRLF&gt;         ::=  octet #x0D octet #x0A</SPAN></PRE><P>
<BR><BR>
</P>
<P LANG="en">This message is designed to be human readable. This
primarily for the purpose of debugging. This message also allows a
peer to be &ldquo;pinged&rdquo; using Telnet or a web browser.</P>
<DL>
	<DT><CODE><SPAN LANG="en">&lt;WELCOMEDEST&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The assumed destination of messages which will be sent on this
	connection. If a received message has no destination address then
	this is the address that should be used. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;WELCOMEADDR&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	The public address of the JXTA Message Transport instance which is
	handling this connection. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;WELCOMEPEER&gt;</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en">
	Provides the peer id of the peer you have reached with this
	connection. 
	</DD><DT>
	<CODE><SPAN LANG="en">&lt;NOPROP&gt;</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">If </SPAN><CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en">
	then the remote peer does not wish to receive propagate/broadcast
	messages on this connection. </SPAN>
	</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="id307972"></A><B>Example&nbsp;2.1.&nbsp;Welcome Message</B></P>
<PRE LANG="en" CLASS="programlisting" STYLE="margin-bottom: 0.5cm">JXTAHELLO tcp://69.3.88.186:34368 tcp://209.25.154.236:9701 urn:jxta:uuid-59616261646162614A7874615032503345A8391EC0914B24B264AF31F297A6FD03 1 1.1</PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="trans-ipt-tcpipmt"></A>2.1.4.&nbsp;Message
Transmission</H3>
<P><SPAN LANG="en">Following the <A HREF="#trans-ipt-tcpipwm">Welcome
Message</A>, the connection is used to send JXTA Messages. Each
message is preceeded by a small amount of header information. The
header information is similar to HTTP headers, but is binary encoded
to provide for lighter-weight parsing.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="id308004"></A><B>Figure&nbsp;2.2.&nbsp;JXTA
Message Package ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;PACKAGE&gt;     ::= &lt;HEADERBLOCK&gt; &lt;BODY&gt;
                                
<SPAN LANG="en">&lt;HEADERBLOCK&gt; ::= (&lt;HEADER&gt;)* &lt;EMPTYHEADER&gt;</SPAN>

<SPAN LANG="en">&lt;HEADER&gt;      ::= &lt;HEADERNAME&gt; &lt;HEADERBODY&gt;</SPAN>

<SPAN LANG="en">&lt;HEADERNAME&gt;  ::= octet [length] (octets)[length]</SPAN>

<SPAN LANG="en">&lt;HEADERBODY&gt;  ::= octet [length msb] octet [length lsb] (octets) [length] </SPAN>

<SPAN LANG="en">&lt;EMPTYHEADER&gt; ::= octet #x00</SPAN>

<SPAN LANG="en">&lt;BODY&gt;        ::= octets</SPAN></PRE><P>
<BR><BR>
</P>
<P><SPAN LANG="en">The header block will contain both required
headers and may contain additional optional headers. The headers are
loosely ordered. Headers of a particular type are considered by
ordered only with respect to other headers of the same type, they
have no order relationship to headers of other types. In general,
headers may appear in any order. The header names are
case-insensitive canonical UTF8 (NFC) (see </SPAN><EM><SPAN LANG="en">Unicode
Standard Annex #15 : Unicode Normalization Forms</SPAN></EM><SPAN LANG="en">
<A HREF="#bib-USA15">USA15</A>) strings.</SPAN></P>
<H4 LANG="en" CLASS="title"><A NAME="id308043"></A>2.1.4.1.&nbsp;JXTA
Message Package - Required Headers</H4>
<P LANG="en">These headers must appear in every message transmission
and have no default values.</P>
<DL>
	<DT STYLE="margin-bottom: 0.5cm"><CODE><SPAN LANG="en">content-length</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">the length of the </SPAN><CODE><SPAN LANG="en">&lt;BODY&gt;</SPAN></CODE><SPAN LANG="en">
	portion. If </SPAN><CODE><SPAN LANG="en">content-coding</SPAN></CODE><SPAN LANG="en">
	headers are included, this length is still the transfer length, not
	the logical length of the body. The header body is an eight octet
	&ldquo;network byte order&rdquo; length.</SPAN></DD><DT STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">content-type</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">The logical type of the message body expressed as a
	MIME-type. The header body consists of a MIME type encoded in
	canonical UTF8 (NFC) using the presentation and encoding of
	</SPAN><EM><SPAN LANG="en">Multipurpose Internet Mail Extensions
	(MIME) Part Two: Media Types</SPAN></EM><SPAN LANG="en"> <A HREF="#bib-RFC2046">RFC2046</A>,
	ie. any encoding specified by RFC 2046 is performed before the
	string is encoded into UTF8 from the implementation native string
	representation.</SPAN></DD><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">Peers must treat unrecognized </SPAN><CODE><SPAN LANG="en">content-type</SPAN></CODE><SPAN LANG="en">
	specifications as an error and close the connection.</SPAN></DD></DL>
<H4 LANG="en" CLASS="title">
<A NAME="id308129"></A>2.1.4.2.&nbsp;JXTA Message Package - Optional
Headers</H4>
<P LANG="en">These headers may appear in any message transmission and
have no default values.</P>
<DL>
	<DT STYLE="margin-bottom: 0.5cm"><CODE><SPAN LANG="en">content-coding</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Specifies a coding which has been applied to the logical message
	body prior to transmission. The header body contains an eight octet
	&ldquo;network byte order&rdquo; value which was the length of the
	message body before encoding. This is followed by the Mime-type of
	the content coding.</DD><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">content-coding</SPAN></CODE><SPAN LANG="en">
	headers are listed in the order in which they were applied, ie. The
	first </SPAN><CODE><SPAN LANG="en">content-coding</SPAN></CODE><SPAN LANG="en">
	header was the first coding applied and will be the last to be
	removed.</SPAN></DD></DL>
<P LANG="en">
All other possible headers are also optional. Unrecognized optional
headers should be ignored.</P>
<H3 LANG="en" CLASS="title"><A NAME="trans-ipt-tcpipmc"></A>2.1.5.&nbsp;IP
Multicast Usage</H3>
<P LANG="en">The TCP Transport may be configured to accept broadcast
messages through IP Multicast. Messages received are not part of an
ongoing connection between peers. Each broadcast message is
idempotent. The datagram is formed similarily to that used for
unicasts connections. It consists of :</P>
<UL TYPE=DISC>
	<LI><P LANG="en">A Welcome Header</P>
	<LI><P LANG="en">A Message Package Header</P>
	<LI><P LANG="en">A single message</P>
</UL>
<P LANG="en">Additionally, in order to fully specify the source of
the message, the Message Package Header must contain the following
header field.</P>
<DL>
	<DT STYLE="margin-bottom: 0.5cm"><CODE><SPAN LANG="en">srcEA</SPAN></CODE><SPAN LANG="en">
	</SPAN>
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The public addresss of the transport which is sending this broadcast
	message.</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="trans-httpt"></A>2.2.&nbsp;HTTP Message Transport</H2>
<P LANG="en">The JXTA HTTP Message Transport is logically divided
into two functions: the initiator and the receiver. The initiator is
able to establish connections, whereas the receiver is able accept
connections. A peer may provide either function or both.</P>
<P LANG="en">The HTTP Message Transport is designed to work
effeciently with or without HTTP 1.1 persistent connections and also
impose a minimum of overhead beyond that required by HTTP itself.</P>
<H3 LANG="en" CLASS="title"><A NAME="trans-httpt-msg-init"></A>2.2.1.&nbsp;The
HTTP Initiator</H3>
<P LANG="en">The HTTP Initiator begins the connection between two
peers. The connection is first used to determine the logical
identities of the participating peers. In most cases, this is simply
a verification as the connection address was chosen by the initiator
to communicate with the desired peer.</P>
<P><SPAN LANG="en">The HTTP Initiator uses two types of HTTP request
to communicate with the recevier. </SPAN><CODE><SPAN LANG="en">GET</SPAN></CODE><SPAN LANG="en">
requests are used for determining the logical identity of the HTTP
Receiver and for polling the HTTP Receiver for messages. </SPAN><CODE><SPAN LANG="en">POST</SPAN></CODE><SPAN LANG="en">
requests are used for sending and receiving JXTA messages with the
receiver.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="trans-httpt-msg-rcvr"></A>2.2.2.&nbsp;The
HTTP Receiver</H3>
<P LANG="en">The HTTP Receiver accepts incoming connections from HTTP
initiators. The HTTP Receiver then acts in response to HTTP requests
from the initiator.</P>
<P><SPAN LANG="en">The HTTP Receiver accepts two types of HTTP
request from the initiator, </SPAN><CODE><SPAN LANG="en">GET</SPAN></CODE><SPAN LANG="en">
requests and </SPAN><CODE><SPAN LANG="en">POST</SPAN></CODE><SPAN LANG="en">
requests. </SPAN><CODE><SPAN LANG="en">GET</SPAN></CODE><SPAN LANG="en">
requests can be used for two tasks: determining the logical identity
of the receiver, polling for messages destined to the initiator. </SPAN><CODE><SPAN LANG="en">POST</SPAN></CODE><SPAN LANG="en">
requests are used to send messages to the receiver and optionally to
receive messages from the receiver.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="trans-httpt-msg-msgs"></A>2.2.3.&nbsp;HTTP
Messages</H3>
<H4 LANG="en" CLASS="title"><A NAME="id282246"></A>2.2.3.1.&nbsp;&ldquo;Ping&rdquo;
Command</H4>
<P LANG="en">The &ldquo;ping&rdquo; command is used to determine the
logical identity (peer id) of a receiver. It also has the effect of
determining connectivity (hence the name).</P>
<P LANG="en">The HTTP initiator issues a request as follows:</P>
<DL>
	<DT LANG="en">Request 
	</DT><DD>
	<CODE><SPAN LANG="en">GET</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DD><DT LANG="en">
	Resource 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">/</SPAN></CODE><SPAN LANG="en"> </SPAN>
	</DD></DL>
<P LANG="en">
The HTTP Receiver should respond to well-formed requests as follows:</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Response Code 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">200</SPAN></CODE></DD><DT LANG="en">
	Required Headers 
	</DT><DL>
		<DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">Content-Length</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		Must always be present.</DD><DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">Content-Type</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en">Must be </SPAN><CODE><SPAN LANG="en">text/plain;charset=&quot;UTF-8&quot;</SPAN></CODE><SPAN LANG="en">.</SPAN></DD></DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Response Body 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The peer id of the HTTP receiver expressed as a JXTA Endpoint
	Address.</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="id308272"></A><B>Example&nbsp;2.2.&nbsp;HTTP Ping Example</B></P>
<PRE CLASS="programlisting"><EM><SPAN LANG="en">Request:</SPAN></EM>

<SPAN LANG="en">GET / HTTP/1.1</SPAN>

<EM><SPAN LANG="en">Response:</SPAN></EM>

<SPAN LANG="en">200 </SPAN>
<SPAN LANG="en">content-length=61</SPAN>
<SPAN LANG="en">content-type=text/plain;charset=&quot;UTF-8&quot;</SPAN>

<SPAN LANG="en">jxta://urn:jxta:uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="id308290"></A>2.2.3.2.&nbsp;&ldquo;Poll&rdquo;
Command</H4>
<P LANG="en">The &ldquo;poll&rdquo; command is used by the HTTP
intiator to retreive a message from the HTTP receivers.</P>
<P LANG="en">The HTTP initiator issues a request as follows:</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Request 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">GET</SPAN></CODE></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Resource 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">/</SPAN></CODE><SPAN LANG="en">&lt;initiator
	peerid&gt;</SPAN><CODE><SPAN LANG="en">?</SPAN></CODE><SPAN LANG="en">&lt;responseWait&gt;,&lt;extraResponseWait&gt;,&lt;destAddr&gt;</SPAN></DD><DL>
		<DT LANG="en" STYLE="margin-bottom: 0.5cm">
		initiator peerid 
		</DT><DD STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en">The unique portion of the peerid of the initiator,
		ie. without the </SPAN><CODE><SPAN LANG="en">urn:jxta:</SPAN></CODE><SPAN LANG="en">
		prefix.</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
		responseWait 
		</DT><DD STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en">The maximum duration in milliseconds which the HTTP
		Receiver should wait in order to send a response. Expressed as a
		decimal integer. This is the longest duration that the initiator is
		willing to wait for a response. If unspecified, the HTTP receiver
		must assume a value of </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
		(zero). A delay value of </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
		(zero) implies that the HTTP Receiver should wait indefinitely
		until a response is available. Negative wait values imply that the
		receiver must not return any response.</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
		lazyClose 
		</DT><DD STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en">The maximum duration in milliseconds during which
		the HTTP Receiver should send additional response messages.
		Expressed as a decimal integer. If unspecified the receiver must
		assume a value of </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
		(zero). A delay value of </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
		(zero) implies that the HTTP receiver should continue to return
		message responses until the connection is closed. Negative values
		imply that the receiver must not return any additional responses.</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
		destAddr 
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		A URI specifying the complete destination address for this
		connection. If there is no destination specified, the receiver must
		assume a value of the address of the receiving network interface
		and receiving port. The destination service and service parameter
		are both uninitialized.</DD></DL>
</DL>
<P LANG="en">
The HTTP Receiver should respond to well-formed requests as follows:</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Response Code 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">200</SPAN></CODE></DD><DT LANG="en">
	Required Headers 
	</DT><DL>
		<DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">Content-Type</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		Must match the content type of the JXTA Message Body which forms
		the response, if any.</DD></DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Response Body 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Well-formed JXTA Message Bodies</DD></DL>
<P LANG="en" CLASS="title">
<A NAME="id308557"></A><B>Example&nbsp;2.3.&nbsp;HTTP Poll Example</B></P>
<PRE CLASS="programlisting"><EM><SPAN LANG="en">Request:</SPAN></EM>

<SPAN LANG="en">POST /uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503?0,0,http://64.81.53.91:8720/EndpointService:jxta-NetGroup/uuid-DEADBEEFDEAFBABAFEEDBABE0000000F05/connect,29988,keep,true HTTP/1.1</SPAN>

<EM><SPAN LANG="en">Response:</SPAN></EM>

<SPAN LANG="en">200 </SPAN>
<SPAN LANG="en">content-length=0</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="id308576"></A>2.2.3.3.&nbsp;&ldquo;Send&rdquo;
Command</H4>
<P LANG="en">The &ldquo;send&rdquo; command is used by the HTTP
intiator to send a message to the HTTP receiver and optional retrieve
a response message.</P>
<P LANG="en">The HTTP initiator issues a request as follows:</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Request 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">POST</SPAN></CODE></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Resource 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">/&lt;initiator peerid&gt;</SPAN></CODE></DD><DL>
		<DT LANG="en" STYLE="margin-bottom: 0.5cm">
		initiator peerid 
		</DT><DD STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en">The unique portion of the peerid of the initiator,
		ie. without the </SPAN><CODE><SPAN LANG="en">urn:jxta:</SPAN></CODE><SPAN LANG="en">
		prefix.</SPAN></DD></DL>
	<DT LANG="en">
	Required Headers 
	</DT><DL>
		<DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">Content-Length</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		Must always be present.</DD><DT STYLE="margin-bottom: 0.5cm">
		<CODE><SPAN LANG="en">Content-Type</SPAN></CODE><SPAN LANG="en"> </SPAN>
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		Must match the content type of the JXTA Message Body which forms
		the response.</DD></DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Request Body 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A well-formed JXTA Message Body</DD></DL>
<P LANG="en">
The HTTP Receiver should respond to well-formed requests as follows:</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Response Code 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">200</SPAN></CODE></DD></DL>
<P LANG="en" CLASS="title">
<A NAME="id308735"></A><B>Example&nbsp;2.4.&nbsp;HTTP Send Example</B></P>
<PRE CLASS="programlisting"><EM><SPAN LANG="en">Request:</SPAN></EM>

<SPAN LANG="en">POST /uuid-59616261646162614A7874615032503304BD268FA4764960AB93A53D7F15044503 HTTP/1.1</SPAN>

<EM><SPAN LANG="en">Response:</SPAN></EM>
                                
<SPAN LANG="en">200 </SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H2 LANG="en" CLASS="title"><A NAME="trans-tlst"></A>2.3.&nbsp;TLS
Transport Binding</H2>
<H3 LANG="en" CLASS="title"><A NAME="trans-tlst-intro"></A>2.3.1.&nbsp;Introduction</H3>
<P><SPAN LANG="en">JXTA implements &ldquo;IETF RFC 2246 : Transport
Layer Security Version 1&rdquo; <A HREF="#bib-RFC2246">RFC2246</A> on
top of the <A HREF="#trans-router">Endpoint Router Transport Protocol</A>
using JXTA messages. Messages are transmitted across one of the other
Transport Bindings. This implementation provides for secure message
delivery between Peer Endpoints even when multiple hops across JXTA
peers must be used.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="trans-tlst-msgs"></A>2.3.2.&nbsp;TLS
Messages</H3>
<P LANG="en">The TLS protocol exchange is accomplished between the
participant peers using JXTA Messages. Three JXTA Message Element
types are used to implement the protocol:</P>
<UL TYPE=DISC>
	<LI><P LANG="en">TLS Contents</P>
	<LI><P LANG="en">Acknowledgements</P>
	<LI><P LANG="en">Retries</P>
</UL>
<H4 LANG="en" CLASS="title"><A NAME="trans-tlst-msgs-msg"></A>2.3.2.1.&nbsp;TLS
Content Element</H4>
<P LANG="en">Used to transfer TLS content between peers.</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Element Name 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	UTF-8 String containing the sequence number of this element.
	Sequence numbers are monotonically increasing positive integers.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Element Type 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">application/x-jxta-tls-block</SPAN></CODE></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Element Data 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">TLS Protocol Data per &ldquo;IETF RFC 2246&rdquo;
	<A HREF="#bib-RFC2246">RFC2246</A></SPAN></DD></DL>
<H4 LANG="en" CLASS="title">
<A NAME="trans-tlst-msgs-ack"></A>2.3.2.2.&nbsp;TLS ACK Element</H4>
<P LANG="en">Used to transfer TLS content between peers.</P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Element Name 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">TLSACK</SPAN></CODE><SPAN LANG="en"> as a
	UTF-8 String.</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Element Type 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">application/x-jxta-tls-ack</SPAN></CODE></DD><DT LANG="en">
	Element Data 
	</DT><DL>
		<DT LANG="en" STYLE="margin-bottom: 0.5cm">
		Sequential ACK 
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		Network Byte Order Unsigned 32 Bit Integer. Indicates that the
		remote peer has successfully received all of the messages with
		sequence numbers up to and including this value.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
		Selective ACKs (optional) 
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
		Network Byte Order Unsigned 32 Bit Integer(s). Each entry is the
		sequence number of a message which has been successfully received
		by the remote peer. Entries are all greater than the sequential ACK
		value and in numerically increasing order.</DD></DL>
</DL>
<H4 LANG="en" CLASS="title">
<A NAME="trans-tlst-msgs-retry"></A>2.3.2.3.&nbsp;Retry Element</H4>
<P><SPAN LANG="en">Used to signify that this message is being sent as
a retry of an apparently failed previous send attempt. If present,
this element will accompany a <A HREF="#trans-tlst-msgs-msg">TLS
Content Element</A>. The element is mostly informational, but can be
used to assist in window control.</SPAN></P>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">Element Name 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">MARKRetr</SPAN></CODE><SPAN LANG="en"> as a
	UTF-8 String.</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Element Type 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">text/plain;charset=&quot;UTF-8&quot;</SPAN></CODE></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	Element Data 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<CODE><SPAN LANG="en">TLSRET</SPAN></CODE><SPAN LANG="en"> as a
	UTF-8 string.</SPAN></DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="msgs-fmts"></A>Chapter&nbsp;3.&nbsp;JXTA Message Wire
Representations</H2>
<P><SPAN LANG="en">In order to send JXTA messages between peers JXTA
a serialized &ldquo;wire&rdquo; encoding of the message must be
created. The standard JXTA </SPAN><EM><A HREF="#gloss-messageTransport"><SPAN LANG="en">Message
Transport</SPAN></A></EM><SPAN LANG="en"> implementations use a
common set of wire encodings. There are two standard message encoding
formats for JXTA Messages, XML and binary. Each JXTA Message
Transport uses the encoding format most appropriate for its'
capabilities.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="id310772"></A>3.1.&nbsp;General
Requirements</H2>
<P LANG="en">Message encoding formats for Message Transports must
allow for the faithful transmission of arbitrary messages.</P>
<P LANG="en">Message Elements with duplicate names must be supported.</P>
<H2 LANG="en" CLASS="title"><A NAME="msgs-fmts-jbm"></A>3.2.&nbsp;Binary
Message Format</H2>
<P><SPAN LANG="en">XML</SPAN><SPAN LANG="en"> and other textual
representations such as </SPAN><SPAN LANG="en">MIME</SPAN><SPAN LANG="en">
<A HREF="#bib-RFC2045">RFC2045</A> are inefficient for the
transmission of arbitrary application data. The JXTA Binary Message
Format is designed to facilitate the efficient transmission of data
between peers.</SPAN></P>
<P LANG="en">Message Transports which are capable of sending and
receiving unencoded binary data will probably prefer to use the
Binary Message Format. This format is designed such that all
components are of declared size, no parsing is ever required to
determine lengths.</P>
<H3 LANG="en" CLASS="title"><A NAME="id310834"></A>3.2.1.&nbsp;Conventions</H3>
<P><SPAN LANG="en">Multi-byte lengths are sent with the high order
byte first (also known as &quot;Big Endian&quot; or &quot;Network
Byte Order&quot;). All strings start with a two byte length, followed
by a UTF string value. The message format is specified using </SPAN><SPAN LANG="en">ABNF</SPAN><SPAN LANG="en">
<A HREF="#bib-RFC2234">RFC2234</A>. </SPAN><SPAN LANG="en">ABNF</SPAN><SPAN LANG="en">
is normally used for </SPAN><SPAN LANG="en">ASCII</SPAN><SPAN LANG="en">
grammars, but here we use it to define a byte sequence for a binary
message.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="jbmv1"></A>3.2.2.&nbsp;Binary
Message Version 1</H3>
<P LANG="en" CLASS="title"><A NAME="fjbmabnf"></A><B>Figure&nbsp;3.1.&nbsp;JXTA
Binary Message Version 1 ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">msg        ::= &quot;jxmg&quot;             ; signature (0x6a 0x78 0x6d 0x67)

               <SPAN LANG="en">version            ; One byte. &quot;0&quot;.</SPAN>

               <SPAN LANG="en">namespaces</SPAN>

               <SPAN LANG="en">element_count      ; two bytes (binary)</SPAN>

               <SPAN LANG="en">1* elm</SPAN>

<SPAN LANG="en">namespaces ::= namespace_count    ; two bytes (binary)</SPAN>

               <SPAN LANG="en">0* namespace       ; Each namespace is a string</SPAN>

<SPAN LANG="en">namespace  ::= string</SPAN>
               
<SPAN LANG="en">string     ::= len2               ; two bytes (binary)</SPAN>
               
               <SPAN LANG="en">len2 * UTF8 chars  ; characters</SPAN>

<SPAN LANG="en">elm        ::= &quot;jxel&quot;             ; signature (0x6a 0x78 0x65 0x6c)</SPAN>

               <SPAN LANG="en">namespaceid        ; one byte (binary)</SPAN>

               <SPAN LANG="en">flags              ; Indicates which parts follow (binary)</SPAN>

               <SPAN LANG="en">name               ; element name</SPAN>

               <SPAN LANG="en">[type]             ; Present if (flags &amp; HAS_TYPE)</SPAN>

               <SPAN LANG="en">[encoding]         ; Present if (flags &amp; HAS_ENCODING)</SPAN>

               <SPAN LANG="en">len4               ; Four byte binary length of content</SPAN>

               <SPAN LANG="en">content            ; element content</SPAN>
         
               <SPAN LANG="en">[signature]        ; associated signature element</SPAN>
                                  <SPAN LANG="en">; Present if (flags &amp; HAS_SIGNATURE) </SPAN>

<SPAN LANG="en">name       ::= string</SPAN>

<SPAN LANG="en">type       ::= string             ; Mime Media Type <A HREF="#bib-RFC2046">RFC2046</A></SPAN>

<SPAN LANG="en">encoding   ::= string             ; Mime Media Type <A HREF="#bib-RFC2046">RFC2046</A></SPAN>

<SPAN LANG="en">content    ::= len4 * byte        ; the bytes of the content.</SPAN>
                    
<SPAN LANG="en">signature  ::= elm</SPAN>

<SPAN LANG="en">flags      ::= byte               ; HAS_TYPE      = 0x01;</SPAN>
                                  <SPAN LANG="en">; HAS_ENCODING  = 0x02;</SPAN>
                                  <SPAN LANG="en">; HAS_SIGNATURE = 0x04;</SPAN></PRE><P>
<BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="id310909"></A>3.2.2.1.&nbsp;Message
Header</H4>
<P><SPAN LANG="en">Each message starts with the four byte signature
</SPAN><CODE><SPAN LANG="en">jxmg</SPAN></CODE><SPAN LANG="en">.
(</SPAN><CODE><SPAN LANG="en">0x6a 0x78 0x6d 0x67</SPAN></CODE><SPAN LANG="en">)
The signature is used to aid in sanity checking a transport
implementation. This is followed by a one byte version number which
must </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
(zero). Next is a list of namespaces used by this message. See the
production rule for namespaces below. And last is a two byte element
count followed by the elements themselves.</SPAN></P>
<H4 LANG="en" CLASS="title"><A NAME="id310934"></A>3.2.2.2.&nbsp;Namespaces</H4>
<P><SPAN LANG="en">Each message element a member of a namespace. The
namespaces of all elements are placed into an ordered list at the
start of the message. Each entry in the list is assigned an id. The
first entry in the list is assigned an id of </SPAN><CODE><SPAN LANG="en">2</SPAN></CODE><SPAN LANG="en">.
The id of each successive namespace is one plus the id of the
preceding namespace. The ids </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">,
and </SPAN><CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en"> are
preassigned. </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
represents the empty namespace. </SPAN><CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en">
is the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace. See <A HREF="#msgs-namespace">Namespace</A> for
information regarding use of namespaces.</SPAN></P>
<P LANG="en">The namespaces portion of a binary message starts with a
two byte namespace count. The count is followed by a sequence of
namespace names. It is permissible for this sequence to be empty.</P>
<H4 LANG="en" CLASS="title"><A NAME="id310982"></A>3.2.2.3.&nbsp;Message
Element Header</H4>
<P><SPAN LANG="en">Each message elements starts with the four byte
signature </SPAN><CODE><SPAN LANG="en">jxel</SPAN></CODE><SPAN LANG="en">
(</SPAN><CODE><SPAN LANG="en">0x6a 0x78 0x65 0x6c</SPAN></CODE><SPAN LANG="en">).
The signature is used to aid in sanity checking a transport
implementation. Next is the namespace id byte. This byte indicates
which name space this element belongs to. The next byte is the flags
byte. Bits in this flag byte indicate which of the optional
components of an element are present. </SPAN><CODE><SPAN LANG="en">HAS_ENCODING</SPAN></CODE><SPAN LANG="en">
is currently unsupported.</SPAN></P>
<P><SPAN LANG="en">The flags are followed by the element name. The
MIME Media Type of the element, if present, follows the element name.
If the type is not specified for an element then the type
</SPAN><CODE><SPAN LANG="en">application/octet-stream</SPAN></CODE><SPAN LANG="en">
is assumed. The element type is optionally followed by the encoding
type. Next is the four byte length of the content, followed by the
content data of the element.</SPAN></P>
<H3 LANG="en" CLASS="title"><A NAME="jbmv2"></A>3.2.3.&nbsp;Binary
Message Version 2</H3>
<P LANG="en">In mid-2006 a new version of the JXTA Binary Message was
developed. This new version currently remains optional for all JXTA
implementations. The new version was developed in order to reduce the
wire overhead of JXTA Binary Messages and to improve support for
larger messages, non-UTF8 character encodings and content encoding.</P>
<P LANG="en" CLASS="title"><A NAME="fjbmabnf2"></A><B>Figure&nbsp;3.2.&nbsp;JXTA
Binary Message Version 2 ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">msg         ::= &quot;jxmg&quot;             ; signature (0x6a 0x78 0x6d 0x67)
                <SPAN LANG="en">version            ; One byte. &quot;1&quot;.</SPAN>
                <SPAN LANG="en">flags              ; UTF-16BE String = 0x01</SPAN>
                                   <SPAN LANG="en">; UTF-32BE String = 0x02</SPAN>
                <SPAN LANG="en">namestable         ; Common names used in element headers</SPAN>
                <SPAN LANG="en">element_count      ; The number of message elements or zero</SPAN>
                <SPAN LANG="en">element_count * element</SPAN>

<SPAN LANG="en">namestable  ::= names_count        ; Number of names defined in the table.</SPAN>
                                   <SPAN LANG="en">; Does not include implicit names.</SPAN>
                <SPAN LANG="en">names_count * string  ; names_count names</SPAN>

<SPAN LANG="en">names_count ::= 2 * byte           ; 2 byte MSB</SPAN>

<SPAN LANG="en">string      ::= len2               ; string length</SPAN>
                <SPAN LANG="en">len2 * chars       ; characters (UTF-8, UTF-16BE, UTF-32BE per flags)               </SPAN>

<SPAN LANG="en">element     ::= &quot;jxel&quot;             ; signature (0x6a 0x78 0x65 0x6c)</SPAN>
                <SPAN LANG="en">flags              ; Flags for Message Element</SPAN>
                                   <SPAN LANG="en">; Body lengths are UINT64 = 0x01</SPAN>
                                   <SPAN LANG="en">; Element Name is literal = 0x02</SPAN>
                                   <SPAN LANG="en">; Element has MIME Type = 0x04</SPAN>
                                   <SPAN LANG="en">; Element has Signature Element = 0x08</SPAN>
                                   <SPAN LANG="en">; Element has Content Encodings = 0x10</SPAN>
                                   <SPAN LANG="en">; Signature is of encoded element body = 0x20</SPAN>
                <SPAN LANG="en">namespaceid        ; name</SPAN>
                <SPAN LANG="en">(name | string)    ; (see flag 0x02)</SPAN>
                <SPAN LANG="en">[type]             ; (see flag 0x04)</SPAN>
                <SPAN LANG="en">[encodings]        ; (see flag 0x10)</SPAN>
                <SPAN LANG="en">elementLen         ; length of content (see flag 0x01)</SPAN>
                <SPAN LANG="en">content            ; element content</SPAN>
                <SPAN LANG="en">[signature]        ; associated signature element</SPAN>
                                   <SPAN LANG="en">; (see flag 0x10)</SPAN>
                                  
<SPAN LANG="en">type        ::= name               ; Mime Media Type <A HREF="#bib-RFC2046">RFC2046</A></SPAN>

<SPAN LANG="en">encodings   ::= num_encodings      ; number of encodings</SPAN>
                <SPAN LANG="en">num_encodings * encoding</SPAN>
               
<SPAN LANG="en">encoding    ::= elementLen         ; pre-encoded element length</SPAN>
                <SPAN LANG="en">name               ; encoding mime type.</SPAN>
                
<SPAN LANG="en">num_encodings ::= len1             ; 1 byte length</SPAN>

<SPAN LANG="en">elementLen  ::= (len4 | len8)      ; len4 or len8 (see flag 0x01)</SPAN>

<SPAN LANG="en">content     ::= elementLen * byte  ; the bytes of the content.</SPAN>

<SPAN LANG="en">signature   ::= element            ; signature message element</SPAN>

<SPAN LANG="en">len1        ::= 1 * byte           ; 1 byte length</SPAN>

<SPAN LANG="en">len2        ::= 2 * byte           ; 2 byte length (MSB order)</SPAN>

<SPAN LANG="en">len4        ::= 4 * byte           ; 4 byte length (MSB order)</SPAN>

<SPAN LANG="en">len8        ::= 8 * byte           ; 8 byte length (MSB order)</SPAN>

<SPAN LANG="en">name        ::= (2 * byte | 0xFFFF {string})</SPAN></PRE><P>
<BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="id311070"></A>3.2.3.1.&nbsp;Message
Header</H4>
<P><SPAN LANG="en">Each JXTA Binary Message begins with a header that
provides basic parametes and options for the message. The message
header starts with a four byte signature, </SPAN><CODE><SPAN LANG="en">jxmg</SPAN></CODE><SPAN LANG="en">
(</SPAN><CODE><SPAN LANG="en">0x6a 0x78 0x6d 0x67</SPAN></CODE><SPAN LANG="en">).
The signature is used to aid in sanity checking a transport
implementation. This is followed by a one byte version number which
must be </SPAN><CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en">.
The version number is followed by message flags. These flags apply to
all message elements included in the message. Following the flags is
a list of names used by this message. The Message Header ends with a
count of the Message Elements which will follow. The element count
may also be zero indicating that the message elements are uncounted.</SPAN></P>
<H4 LANG="en" CLASS="title"><A NAME="id311109"></A>3.2.3.2.&nbsp;Names
Table</H4>
<P><SPAN LANG="en">Every message includes a table of names (strings).
The names table provides a mechanism for looking up commonly used
Message Element header strings. Each entry in the list is assigned an
ID. The first entry in the list is assigned an id of </SPAN><CODE><SPAN LANG="en">2</SPAN></CODE><SPAN LANG="en">.
The ID of each successive name is one plus the id of the preceding
names. The IDs </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">,
</SPAN><CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en">, and
</SPAN><CODE><SPAN LANG="en">0xFFFF</SPAN></CODE><SPAN LANG="en"> are
preassigned. </SPAN><CODE><SPAN LANG="en">0</SPAN></CODE><SPAN LANG="en">
represents the empty namespace. </SPAN><CODE><SPAN LANG="en">1</SPAN></CODE><SPAN LANG="en">
is the </SPAN><CODE><SPAN LANG="en">jxta</SPAN></CODE><SPAN LANG="en">
namespace. </SPAN><CODE><SPAN LANG="en">0xFFFF</SPAN></CODE><SPAN LANG="en">
is used when a literal name must be used within a Message Element.
Generally this happens when messages are created on-the-fly and the
name was not known at the time the Message was begun.</SPAN></P>
<P LANG="en">The names table portion of a JXTA Binary Message starts
with a two byte names count. The count is followed by a sequence of
name strings. It is permissible for this sequence to be empty.</P>
<H4 LANG="en" CLASS="title"><A NAME="id311162"></A>3.2.3.3.&nbsp;Message
Element Header</H4>
<P><SPAN LANG="en">Each Message Element header starts with the four
byte signature </SPAN><CODE><SPAN LANG="en">jxel</SPAN></CODE><SPAN LANG="en">
(</SPAN><CODE><SPAN LANG="en">0x6a 0x78 0x65 0x6c</SPAN></CODE><SPAN LANG="en">).
The signature is used to aid in sanity checking a transport
implementation. The signature is followed by the Message Element
flags. The flags control Message Element specific options. The flags
are followed by the namespace ID. Each Message Element is part of a
specific namespace. The name space ID identifies the name of the
namespace. The namespace is followed by the name of the Message
Element. Depending upon the setting of flag #1 this may be either a
name ID or a string literal. String literals are commonly used for
names which only occur once within the context of a message.
Optionally following the Message Element Name is the Message Element
Type. The Message Element Type identifies the MIME multimedia type
associated with this message element's content. If no Message Element
Type is included then the MIME type is assumed to be
</SPAN><CODE><SPAN LANG="en">application/octet-stream</SPAN></CODE><SPAN LANG="en">.
Following the type is the optional content encoding information. If
present the content encoding information describes any content
transformations which have been applied to the Message Element
content and must be reversed in order to recover the content.
Examples of content encoding include compression, chunking and
encryption. Following the content encoding information is the Message
Element content length. The content length specifies the size in
bytes of the encoded Message Element content. The content length is
followed by the Message Element content which may need to be
unencoded as it is processed.</SPAN></P>
<H2 LANG="en" CLASS="title"><A NAME="id311199"></A>3.3.&nbsp;XML
Message Format</H2>
<P LANG="en">The XML message format is used for transports which can
transmit text but not raw binary data. An effort is made to keep the
message elements as readable as possible. See the section on
encoding.</P>
<H3 LANG="en" CLASS="title"><A NAME="id311211"></A>3.3.1.&nbsp;Message</H3>
<P LANG="en" CLASS="title"><A NAME="msgs-exm"></A><B>Example&nbsp;3.1.&nbsp;XML
Message</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;?xml version=&quot;1.0&quot;?&gt;

<SPAN LANG="en">&lt;!DOCTYPE Message&gt;</SPAN>

<SPAN LANG="en">&lt;Message version=&quot;0&quot;&gt;</SPAN>
 <SPAN LANG="en">&lt;Element name=&quot;jxta:SourceAddress&quot; mime_type=&quot;text/plain&quot;&gt;</SPAN>
  <SPAN LANG="en">tcp://123.456.205.212</SPAN>
 <SPAN LANG="en">&lt;/Element&gt;</SPAN>
 <SPAN LANG="en">&lt;Element name=&quot;stuff&quot; encoding=&quot;base64&quot; mime_type=&quot;application/octet-stream&quot;&gt;</SPAN>
  <SPAN LANG="en">AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4</SPAN>
  <SPAN LANG="en">OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3Bx</SPAN>
  <SPAN LANG="en">cnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmq</SPAN>
  <SPAN LANG="en">q6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsc=</SPAN>
 <SPAN LANG="en">&lt;/Element&gt;</SPAN>
<SPAN LANG="en">&lt;/Message&gt;</SPAN>
   </PRE><P>
<BR><BR>
</P>
<P LANG="en">The top level XML element is the Message element. There
is one required attribute, version. The value of version must be zero
&quot;0&quot;. The body of the Message element is a sequence of
Element elements.</P>
<H3 LANG="en" CLASS="title"><A NAME="id311249"></A>3.3.2.&nbsp;Element</H3>
<P LANG="en">Each Element must have a name and mime_type attribute.
Optionally an encoding attribute may be present.</P>
<H4 LANG="en" CLASS="title"><A NAME="id311260"></A>3.3.2.1.&nbsp;Name</H4>
<P LANG="en">This a required attribute names the element. The name
contains the namespace, followed by a colon, followed by the simple
name of the element.</P>
<H4 LANG="en" CLASS="title"><A NAME="id311273"></A>3.3.2.2.&nbsp;MIME
type</H4>
<P LANG="en">A required attribute indicating the MIME type of the
element. If the MIME type was not specified in the message, a type of
&quot;application/octet-stream&quot; is used.</P>
<H4 LANG="en" CLASS="title"><A NAME="id311286"></A>3.3.2.3.&nbsp;Encoding</H4>
<P><SPAN LANG="en">Encoding is optional The only supported encoding
at this time is base64. &ldquo;IETF RFC 1521&rdquo; <A HREF="#bib-RFC1521">RFC1521</A>
If the encoding is not present, the content is just treated as a
string. While name, type and content are parts of a message which
will be found in all implementations, the encoding is added by this
particular format.</SPAN></P>
<P LANG="en">Note: The reference implementation uses the following
technique to select encoding. If the MIME major type is &quot;text&quot;,
the content is treated as a string. Therefore, no encoding attribute
is present on the element. Otherwise the content is base64 encoded.
This will result in human readable text where possible. The content
will successfully be transferred using an XML message even if the
user has incorrectly specified the MIME type. There is no requirement
that an implementation follow this rule. Implementations will still
interoperate whether or not this rule is used.</P>
<H1 LANG="en" CLASS="title"><A NAME="refimpls"></A>Part&nbsp;3.&nbsp;JXTA
Reference Implementations Information</H1>
<H1 LANG="en" CLASS="title"><A NAME="refimpls-i"></A>Introduction</H1>
<P LANG="en">In order to deliver complete JXTA implementations, the
developers of the various JXTA Reference Bindings have produced a
number of components which implement parts of the JXTA specification,
but are either not required by the core specification or not
specified. This section describes some of these components. These
implementations may not be present in all JXTA Bindings and Binding
developers are not required to support them.</P>
<P LANG="en"><B>Table of Contents</B></P>
<DL>
	<DT><SPAN LANG="en"><A HREF="#refimpl-j2se">1. Java 2 SE Reference
	Implementation</A> </SPAN>
	</DT><DL>
		<DT>
		<SPAN LANG="en"><A HREF="#refimpl-j2se-ids">1.1. JXTA ID Formats</A>
		</SPAN>
		</DT><DT STYLE="margin-bottom: 0.5cm">
		<SPAN LANG="en"><A HREF="#trans-router-refimpl">1.2. J2SE JXTA
		Endpoint Router Implementation</A> </SPAN>
		</DT></DL>
</DL>
<H2 LANG="en" CLASS="title">
<A NAME="refimpl-j2se"></A>Chapter&nbsp;1.&nbsp;Java 2 SE Reference
Implementation</H2>
<H2 LANG="en" CLASS="title"><A NAME="refimpl-j2se-ids"></A>1.1.&nbsp;JXTA
ID Formats</H2>
<P LANG="en">These ID Formats have been defined for JXTA Language
Binding Reference Implementations.</P>
<H3 LANG="en" CLASS="title"><A NAME="refimpls-ids-jiuft"></A>1.1.1.&nbsp;JXTA
ID Formats : &ldquo;uuid&rdquo; ID Format</H3>
<P><SPAN LANG="en">The Java 2SE reference implementation of JXTA
provides an implementation of JXTA IDs based upon UUIDs &ldquo;ISO/IEC
11578:1996&rdquo; <A HREF="#bib-ISO11578">ISO11578</A>. This optional
ID Format is identified as the </SPAN><CODE><SPAN LANG="en">uuid</SPAN></CODE><SPAN LANG="en">
format. In this implementation, UUIDs are encoded as hex digits as
the basis generating unique identifiers. At the end of each UUID ID
are two hex characters that identify the type of JXTA ID. Currently,
six ID Types have been defined.</SPAN></P>
<P LANG="en" CLASS="title"><A NAME="ids-fuifa"></A><B>Figure&nbsp;1.1.&nbsp;JXTA
&quot;uuid&quot; ID Format ABNF</B></P>
<PRE LANG="en" CLASS="programlisting">&lt;JXTAUUIDURN&gt;    ::= &quot;urn:&quot; &lt;JXTANS&gt; &quot;:&quot; &lt;JXTAUUIDFMT&gt; &quot;-&quot;
                     <SPAN LANG="en">&lt;(1*(&lt;hex&gt; &lt;hex&gt;)) &lt;JXTAUUIDIDTYPE&gt;</SPAN>

<SPAN LANG="en">&lt;JXTAUUIDFMT&gt;    ::= &quot;uuid&quot;</SPAN>

<SPAN LANG="en">&lt;JXTAUUIDIDTYPE&gt; ::= &lt;CODATID&gt; | &lt;PEERGROUPID&gt; | &lt;PEERID&gt; |</SPAN>
                     <SPAN LANG="en">&lt;PIPEID&gt; | &lt;MODULECLASSID&gt; | &lt;MODULESPECID&gt;</SPAN>

<SPAN LANG="en">&lt;CODATID&gt;        ::= &quot;01&quot;</SPAN>

<SPAN LANG="en">&lt;PEERGROUPID&gt;    ::= &quot;02&quot;</SPAN>

<SPAN LANG="en">&lt;PEERID&gt;         ::= &quot;03&quot;</SPAN>

<SPAN LANG="en">&lt;PIPEID&gt;         ::= &quot;04&quot;</SPAN>

<SPAN LANG="en">&lt;MODULECLASSID&gt;  ::= &quot;05&quot;</SPAN>

<SPAN LANG="en">&lt;MODULESPECID&gt;   ::= &quot;06&quot;</SPAN></PRE><P>
<BR><BR>
</P>
<P LANG="en">The characters preceding the ID Type identifier are the
encoded form of the ID. The encoding consists of a variable number of
characters dependant upon the ID Type being encoded. To decode the ID
the hex characters are translated in order and placed into the
elements of a byte array from which the various ID components can be
retrieved. All of JXTA UUID IDs are currently manipulated as 64 byte
arrays although no ID Type currently requires all the full 64 bytes
to encode their contents. Position 63 always contains the UUID ID
Type value. The remainder of the ID fields are defined beginning at
Position 0 and increment towards Position 63.</P>
<P LANG="en">To make the text presentation of JXTA UUID IDs as URNs
more compact implementations must not encode the value of unused
Positions within the array. Since they are irrelevant to the value of
the ID they can be assumed to be zero. Implementations must also omit
from the encoding the value of any Positions that precede the unused
portion and contain zero. The reference Java implementation
accomplishes this by scanning from Position 62 towards Position 0
searching for the first non-zero value. It then encodes from position
0 to the discovered location followed by the encoding for Position
63. The text encoding of a JXTA ID must be canonical according to the
URN specification, thus this &ldquo;zero-saving&rdquo; technique must
be present in every implementation.</P>
<P LANG="en" CLASS="title"><A NAME="id317933"></A><B>Example&nbsp;1.1.&nbsp;Sample
&quot;uuid&quot; Format ID</B></P>
<PRE LANG="en" CLASS="programlisting">urn:jxta:uuid-00030102040501

<EM><SPAN LANG="en">Decodes to:</SPAN></EM>

<SPAN LANG="en">0:00  1:03  2:01  3:02  4:04  5:05  6-62:00  63:01</SPAN></PRE><P LANG="en">
<BR><BR>
</P>
<H3 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd"></A>1.1.2.&nbsp;JXTA
UUID Field Definitions</H3>
<P LANG="en">Each of the six JXTA ID Types has a specific definition
for how its fields are represented within the common 64-byte array
structure. Common between the six ID Types is the definition of
Position 63. This location is reserved for the ID Type.</P>
<H4 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd-jucif"></A>1.1.2.1.&nbsp;JXTA
UUID Codat ID Fields</H4>
<P LANG="en">Each Codat is assigned a unique codat id that enables
canonical references to be made to the codat in the context of a
specific peer group. A CodatID is formed by the conjunction of a
PeerGroupID, a randomly chosen value that has a high probability of
being unique, and an optional SHA1 cryptographic hash of the codat
contents.</P>
<P LANG="en" CLASS="title"><A NAME="id317979"></A><B>Figure&nbsp;1.2.&nbsp;JXTA
UUID Codat ID Fields</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<TR>
		<TD>
			<P>0:Group MSB</P>
		</TD>
		<TD COLSPAN=5>
			<P>0-15:...GROUP UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=5>
			<P>...GROUP UUID (cont.)...</P>
		</TD>
		<TD>
			<P>15:Group LSB</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>16:ID MSB</P>
		</TD>
		<TD COLSPAN=5>
			<P>16-31:...CODAT UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=5>
			<P>...CODAT UUID (cont.)...</P>
		</TD>
		<TD>
			<P>31:ID LSB</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>32:Hash</P>
		</TD>
		<TD COLSPAN=5>
			<P>32-51:CODAT SHA1 Hash...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=6>
			<P>...CODAT SHA1 Hash...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=2>
			<P>...CODAT SHA1 Hash</P>
		</TD>
		<TD>
			<P>51:Hash</P>
		</TD>
		<TD COLSPAN=3>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=5>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>63:ID Type</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd-jupgif"></A>1.1.2.2.&nbsp;JXTA
UUID PeerGroup ID Fields</H4>
<P LANG="en">Each peer group is assigned a unique id that enables
canonical references to that peer group.</P>
<P LANG="en" CLASS="title"><A NAME="id318142"></A><B>Figure&nbsp;1.3.&nbsp;JXTA
UUID PeerGroup ID Fields</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<TR>
		<TD>
			<P>0:MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>0-15...GROUP UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...GROUP UUID (cont.)</P>
		</TD>
		<TD>
			<P>15:LSB</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>0:MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>0-15...PARENT GROUP UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...PARENT GROUP UUID (cont.)</P>
		</TD>
		<TD>
			<P>15:LSB</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>63:IDType</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd-jupeif"></A>1.1.2.3.&nbsp;JXTA
UUID Peer ID Fields</H4>
<P LANG="en">Each peer is assigned a unique peer id that enables
canonical references to be made to the peer in the context of a
specific peer group.</P>
<P LANG="en" CLASS="title"><A NAME="id318277"></A><B>Figure&nbsp;1.4.&nbsp;JXTA
UUID Peer ID Fields</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<TR>
		<TD>
			<P>0:Group MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>0-15...GROUP UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...GROUP UUID (cont.)</P>
		</TD>
		<TD>
			<P>15:Group LSB</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>16:ID MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>16-31:...PEER UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...PEER UUID (cont.)...</P>
		</TD>
		<TD>
			<P>31:ID LSB</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>63:IDType</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd-jupiif"></A>1.1.2.4.&nbsp;JXTA
UUID Pipe ID Fields</H4>
<P LANG="en">Each pipe is assigned a unique pipe id that enables
canonical references to be made to the pipe in the context of a
specific peer group.</P>
<P LANG="en" CLASS="title"><A NAME="id318412"></A><B>Figure&nbsp;1.5.&nbsp;JXTA
UUID Pipe ID Fields</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<THEAD>
		<TR>
			<TH>
				<P>0</P>
			</TH>
			<TH>
				<P>1</P>
			</TH>
			<TH>
				<P>2</P>
			</TH>
			<TH>
				<P>3</P>
			</TH>
			<TH>
				<P>4</P>
			</TH>
			<TH>
				<P>5</P>
			</TH>
			<TH>
				<P>6</P>
			</TH>
			<TH>
				<P>7</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR>
			<TH>
				<P>0</P>
			</TH>
			<TH>
				<P>1</P>
			</TH>
			<TH>
				<P>2</P>
			</TH>
			<TH>
				<P>3</P>
			</TH>
			<TH>
				<P>4</P>
			</TH>
			<TH>
				<P>5</P>
			</TH>
			<TH>
				<P>6</P>
			</TH>
			<TH>
				<P>7</P>
			</TH>
		</TR>
		<TR>
			<TD>
				<P>0:Group MSB</P>
			</TD>
			<TD COLSPAN=7>
				<P>0-15...GROUP UUID...</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=7>
				<P>...GROUP UUID (cont.)</P>
			</TD>
			<TD>
				<P>15:Group LSB</P>
			</TD>
		</TR>
		<TR>
			<TD>
				<P>16:ID MSB</P>
			</TD>
			<TD COLSPAN=7>
				<P>16-31:...PIPE UUID...</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=7>
				<P>...PIPE UUID (cont.)...</P>
			</TD>
			<TD>
				<P>31:ID LSB</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=8>
				<P>&nbsp;</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=8>
				<P>&nbsp;</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=8>
				<P>&nbsp;</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=7>
				<P>&nbsp;</P>
			</TD>
			<TD>
				<P>63:IDType</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd-jumcif"></A>1.1.2.5.&nbsp;JXTA
UUID Module Class ID Fields</H4>
<P LANG="en">Each Module is assigned a Module service id that enables
canonical references to be made to the service in the context of a
specific peer group and optionally within the context of a specific
peer.</P>
<P LANG="en" CLASS="title"><A NAME="id318645"></A><B>Figure&nbsp;1.6.&nbsp;JXTA
UUID Module Class ID Fields</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<TR>
		<TD>
			<P>0:MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>0-15...MODULE UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...MODULE UUID (cont.)</P>
		</TD>
		<TD>
			<P>15:LSB</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>63:IDType</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H4 LANG="en" CLASS="title"><A NAME="refimpls-ids-jufd-jumsif"></A>1.1.2.6.&nbsp;JXTA
UUID Module Spec ID Fields</H4>
<P LANG="en">Each Service is assigned a unique service id that
enables canonical references to be made to the service in the context
of a specific peer group and optionally within the context of a
specific peer.</P>
<P LANG="en" CLASS="title"><A NAME="id318773"></A><B>Figure&nbsp;1.7.&nbsp;JXTA
UUID Module Spec ID Fields</B></P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=2>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<COL WIDTH=0>
	<TR>
		<TD>
			<P>0:CLASS MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>0-15...MODULE CLASS...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...MODULE CLASS (cont.)</P>
		</TD>
		<TD>
			<P>15:CLASS LSB</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>16:SPEC MSB</P>
		</TD>
		<TD COLSPAN=3>
			<P>16-31:...SPEC UUID...</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>...SPEC UUID (cont.)...</P>
		</TD>
		<TD>
			<P>31:SPEC LSB</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=4>
			<P>&nbsp;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=3>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>63:IDType</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en"><BR><BR>
</P>
<H2 LANG="en" CLASS="title"><A NAME="trans-router-refimpl"></A>1.2.&nbsp;J2SE
JXTA Endpoint Router Implementation</H2>
<P LANG="en">This section describes the implementation of the
Endpoint Router in the J2SE implementation of JXTA. This is just an
example of how the EndpointRouter protocol can be implemented, but
there is several other manners the Endpoint Router could be
implemented. Other optimizations or robustness mechanisms could be
added or changed in other implementations of the Endpoint Router.</P>
<P LANG="en">In this section, the term Endpoint Router refers to the
J2SE Endpoint Router implementation and not to the Endpoint Router
protocol as the term has been used in the previous sections.</P>
<P LANG="en">Also, the current implementation does not yet implement
the entire protocol (pending tasks). What is not yet implemented is
outlined in this document.</P>
<P LANG="en">The Endpoint Router manages a cache of routes to
destination peers.</P>
<P LANG="en">[PENDING TASK] Currently the cache does not associate a
life time to a route in the cache. This is needed as routes are
dynamic and constantly changing in a peer to peer network. A life
time of 15-20 minutes is probably a good guess.</P>
<P LANG="en">When the Endpoint Router is asked to send a message to a
peer for which it does not yet have a route, it sends out a
RouteQuery, using the Resolver Service. When the router is asked to
route a message, if the message contains the forward route, this
route is used, even if the router knows another route (the forward
route within the message takes precedence). If the forward route is
not valid (the next hop in the list is not reachable), or if the
message does not contain a forward route, the local route is then
used. If there is no local route, then the message is dropped.</P>
<P LANG="en">[PENDING TASK] When a router is asked to route a
message, and when no route is available, it should search for a route
(sending a RouteQuery), and/or send a NACK message back to the source
of the message.</P>
<P LANG="en">When the Endpoint Router receives a RouteQuery, if it
knows a route, it answer with a RouteResponse including the forward
route.</P>
<P LANG="en">[PENDING TASK] PingQuery and PingResponse are not yet
implemented. In particular, routes should be checked once in a while.</P>
<P LANG="en">[PENDING TASK] NACK is not yet implemented.</P>
<P LANG="en">When the Endpoint Router receives an incoming message,
and when the incoming message contains a reverse route, the reverse
route is added into the local cache of routes. Note that the Endpoint
Router detects loops and other errors both in reverse route and
forward route.</P>
<P LANG="en">The Endpoint Router does not remove its message element,
even when routed message is eventually delivered locally to the
destination application. This allow the application to decide to
forward the message to another peer, while keeping the routing
information, especially the reverse route, allowing the final
destination to respond to the original source of the message without
having to issue a RouteQuery.</P>
<H2 LANG="en" CLASS="title"><A NAME="id320945"></A>Glossary</H2>
<DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm"><A NAME="gloss-adv"></A>Advertisement
		</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	JXTA's language-neutral metadata structures that describe peer
	resources such as peers, peer groups, pipes, and services.
	Advertisements are represented as XML documents.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-binding"></A>Binding 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	An implementation of the JXTA protocols for a particular environment
	(e.g., the Java J2SE platform binding).</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-codat"></A>Codat 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The combination of a content (commonly a document or file) and a
	JXTA ID.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-credential"></A>Credential 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A token used to uniquely identify the sender of a message; can be
	used to provide message authorization.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-jxta"></A>JXTA 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	JXTA is not an acronym, and in particular the &ldquo;J&rdquo;does
	not refer to Java. JXTA is a made up word coined by the project's
	original sponsor, Bill Joy. JXTA is derived from the word Juxtapose,
	as in side by side. It is a recognition that peer-to-peer is
	juxtaposed to client server or Web based computing -- what is
	considered today's traditional computing model.</DD><DL>
		<DT>
		<STRONG><SPAN LANG="en">jux ta pose</SPAN></STRONG><SPAN LANG="en">
		</SPAN>
		</DT><DD>
		<EM><SPAN LANG="en">tr. v.</SPAN></EM><SPAN LANG="en">To place side
		by side, especially for comparison or contrast. </SPAN>
		</DD></DL>
	<DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-jcs"></A>JXTA Core Specification 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">The JXTA Core Specification consists of the required
	components and behaviours which are present in all conforming JXTA
	implementations. This includes the Endpoint Routing Protocol (</SPAN><SPAN LANG="en">ERP</SPAN><SPAN LANG="en">)
	and the Peer Resolver Protocol (</SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">).</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-idformat"></A>JXTA ID Format 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A JXTA ID Format is a scheme for representing it IDs of JXTA
	entities. Each ID Format is identified by as sub-namespace of the
	URN namespace &quot;jxta&quot;.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-idtype"></A>JXTA ID Type 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A JXTA ID Type is describes the characteristics of JXTA IDs which
	refer to a particular sort of JXTA entity. Currently this includes
	peer groups, peers, codats, pipes, module classes, module
	specifications and module impelmentations, but may be extended to
	refer to other types of entities in the future or in specific
	implementations.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-jss"></A>JXTA Standard Services 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">The JXTA Standard Services are optional JXTA
	components and behaviours. Implementations are not required to
	provide these services, but are strongly recommended to do so. This
	includes Peer Discovery Protocol (</SPAN><SPAN LANG="en">PDP</SPAN><SPAN LANG="en">),
	Peer Information Protocol (</SPAN><SPAN LANG="en">PIP</SPAN><SPAN LANG="en">),
	Pipe Binding Protocol (</SPAN><SPAN LANG="en">PBP</SPAN><SPAN LANG="en">)
	and Rendezvous Protocol (</SPAN><SPAN LANG="en">RVP</SPAN><SPAN LANG="en">).</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-message"></A>Message 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The basic unit of data exchange between JXTA peers; each message
	contains an ordered sequence of named sub-sections, called message
	elements, which can hold any form of data.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-messageTransport"></A>Message Transport 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A Message Transport is responsible for sending and/or receiving JXTA
	messages via an external network. A Message Transport may use
	whatever wire protocol it wishes in order to transmit messages
	between peers. Message Transports must pass the messages between
	peers unaltered.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-module"></A>Module 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	An abstraction used to represent any piece of &quot;code&quot; used
	to implement a behavior in the JXTA world. Network services are the
	mode common example of behavior that can be instantiated on a peer.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-moduleclass"></A>Module Class 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Represents an expected behavior and an expected binding to support
	the module; is used primarily to advertise the existence of a
	behavior.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-moduleimpl"></A>Module Implementation 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The implementation of a given module specification; there may be
	multiple module implementations for a given module specification.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-modulespec"></A>Module Specification 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	Describes a specification of a given module class; it is one
	approach to providing the functionality that a module class implies.
	There can be multiple module specifications for a given module
	class. The module specification is primarily used to access a
	module.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-p2p"></A>Peer-to-Peer (P2P) 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A decentralized networking paradigm in which distributed nodes, or
	peers, communicate and work collaboratively to provide services.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-peer"></A>Peer 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A peer is any uniquely identifiable networked device which is
	capable of interacting with other network devices using standardized
	protocols.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-peergroup"></A>Peer Group 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A collection of peers that have a common set of interests and have
	agreed upon a common set of services.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-prp"></A>Peer Resolver Protocol 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The Peer Resolver Protocol provides a generic query/response
	interface applications and services can use for building resolution
	services.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-rdv"></A>Rendezvous Peer 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	A peer which assumes additional responsibilities for the propagation
	of messages within a peer group.</DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-resolverservice"></A>Resolver Service 
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">Resolver Services are responsible for the routing
	and processing queries and responses within peer groups. Resolver
	Services use the Peer Resolver Protocol (</SPAN><SPAN LANG="en">PRP</SPAN><SPAN LANG="en">)
	for transmission of queries between peers.</SPAN></DD><DT STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-xml"></A><SPAN LANG="en">XML</SPAN><SPAN LANG="en"> </SPAN>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<SPAN LANG="en">(From &ldquo;Extensible Markup Language (XML) 1.0&rdquo;
	<A HREF="#bib-XML10">XML10</A> ) : Extensible Markup Language,
	abbreviated </SPAN><SPAN LANG="en">XML</SPAN><SPAN LANG="en">,
	describes a class of data objects called </SPAN><SPAN LANG="en">XML</SPAN><SPAN LANG="en">
	documents and partially describes the behavior ofcomputer programs
	which process them.</SPAN></DD><DT LANG="en" STYLE="margin-bottom: 0.5cm">
	<A NAME="gloss-worldgroup"></A>World Peer Group 
	</DT><DD LANG="en" STYLE="margin-bottom: 0.5cm">
	The most fundamental peer group within the JXTA network. This core
	peer group is generally responsible only for management of physical
	network connections, physical network (generally broadcast)
	discovery and physical network topology management. Applications
	generally do not interact with this group. May only include limited
	endpoint, resolver, discovery and rendezvous services.</DD></DL>
<H2 LANG="en" CLASS="title">
<A NAME="id322024"></A>Bibliography</H2>
<P LANG="en"><A NAME="bib-ISO11578"></A>[ISO11578] <FONT FACE="sans-serif"><I><B>Information
Technology - Open Systems Interconnection - Remote Procedure Call
(RPC)</B></I></FONT><FONT FACE="sans-serif"><B> .</B></FONT> 1996.
<I>ISO/IEC</I>. 11578:1996. ISO (International Organization for
Standardization).</P>
<P><A NAME="bib-RFC821"></A><SPAN LANG="en">[RFC821] </SPAN><A HREF="http://ietf.org/rfc/rfc821.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Simple
Mail Transfer Protocol (SMTP)</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Jonathan B. Postel. August 1982.
</SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">. 821.
Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC1521"></A><SPAN LANG="en">[RFC1521] </SPAN><A HREF="http://ietf.org/rfc/rfc821.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Multipurpose
Internet Mail Extensions (MIME) Part One: Mechanisms for Specifying
and Describing the Format of Internet Message Bodies</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> N. Borenstein and N. Freed.
September 1993. </SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">.
1521. Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC2045"></A><SPAN LANG="en">[RFC2045] </SPAN><A HREF="http://ietf.org/rfc/rfc2046.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Multipurpose
Internet Mail Extensions (MIME) Part One: Format of Internet Message
Bodies</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> N. Freed and N. Borenstein.
November 1996. </SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">.
2045. Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC2046"></A><SPAN LANG="en">[RFC2046] </SPAN><A HREF="http://ietf.org/rfc/rfc2046.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Multipurpose
Internet Mail Extensions (MIME) Part Two: Media Types</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> N. Freed and N. Borenstein.
November 1996. </SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">.
2046. Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC2119"></A><SPAN LANG="en">[RFC2119] </SPAN><A HREF="http://ietf.org/rfc/rfc2119.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Key
words for use in RFCs to Indicate Requirement Levels</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> S. Bradner. March 1997. </SPAN><SPAN LANG="en"><I>IETF
RFC</I></SPAN><SPAN LANG="en">. 2119. Internet Engineering Task
Force.</SPAN></P>
<P><A NAME="bib-RFC2141"></A><SPAN LANG="en">[RFC2141] </SPAN><A HREF="http://ietf.org/rfc/rfc2141.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>URN
Syntax</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> R. Moats. May 1997. </SPAN><SPAN LANG="en"><I>IETF
RFC</I></SPAN><SPAN LANG="en">. 2141. Internet Engineering Task
Force.</SPAN></P>
<P><A NAME="bib-RFC2234"></A><SPAN LANG="en">[RFC2234] </SPAN><A HREF="http://ietf.org/rfc/rfc2234.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Augmented
BNF for Syntax Specifications: ABNF</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> P. Overell and D. Crocker.
November 1997. </SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">.
2234. Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC2246"></A><SPAN LANG="en">[RFC2246] </SPAN><A HREF="http://ietf.org/rfc/rfc2246.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>The
TLS Protocol : Version 1.0</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Tim Dierks and Christopher Allen.
January 1999. </SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">.
2246. Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC2616"></A><SPAN LANG="en">[RFC2616] </SPAN><A HREF="http://ietf.org/rfc/rfc2616.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Hypertext
Transfer Protocol -- HTTP/1.1</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Roy T. Fielding, James Gettys,
Jeffrey C. Mogul, Henrik Frystyk Nielsen, and Larry Masinter. June
1999. </SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">.
2616. Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC3080"></A><SPAN LANG="en">[RFC3080] </SPAN><A HREF="http://ietf.org/rfc/rfc3080.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>The
Blocks Extensible Exchange Protocol Core</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Marshall T. Rose. March 2001.
</SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">. 3080.
Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-RFC3081"></A><SPAN LANG="en">[RFC3081] </SPAN><A HREF="http://ietf.org/rfc/rfc3081.txt" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>The
Blocks Extensible Exchange Protocol Core</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Marshall T. Rose. March 2001.
</SPAN><SPAN LANG="en"><I>IETF RFC</I></SPAN><SPAN LANG="en">. 3081.
Internet Engineering Task Force.</SPAN></P>
<P><A NAME="bib-USA15"></A><SPAN LANG="en">[USA15] </SPAN><A HREF="http://www.unicode.org/unicode/reports/tr15/" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Unicode
Standard Annex #15: Unicode Normalization Forms</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Mark Davis and Martin D&uuml;rst.
26 March 2002. </SPAN><SPAN LANG="en"><I>Unicode Standard Annex</I></SPAN><SPAN LANG="en">.
15. The Unicode Consortium.</SPAN></P>
<P><A NAME="bib-USA28"></A><SPAN LANG="en">[USA28] </SPAN><A HREF="http://www.unicode.org/unicode/reports/tr28/tr28-3.html" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Unicode
Standard Annex #28: Unicode 3.2</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> The Unicode Consortium. 27 March
2002. </SPAN><SPAN LANG="en"><I>Unicode Standard Annex</I></SPAN><SPAN LANG="en">.
28. The Unicode Consortium.</SPAN></P>
<P><A NAME="bib-XML10"></A><SPAN LANG="en">[XML10] </SPAN><A HREF="http://www.w3.org/TR/REC-xml" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>Extensible
Markup Language (XML) 1.0 (Second Edition)</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> World Wide Web Consortium. 6
October 2000. </SPAN><SPAN LANG="en"><I>W3C Recommendation</I></SPAN><SPAN LANG="en">.
2e. World Wide Web Consortium.</SPAN></P>
<P><A NAME="bib-XSD2001-1"></A><SPAN LANG="en">[XSD2001-1] </SPAN><A HREF="http://www.w3.org/TR/xmlschema-1/" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>XML
Schema Part 1: Structures</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Henry S. Thompson, David Beech,
Murray Maloney, and Noah Mendelsohn. 2 May 2001. W3C.</SPAN></P>
<P><A NAME="bib-XSD2001-2"></A><SPAN LANG="en">[XSD2001-2] </SPAN><A HREF="http://www.w3.org/TR/xmlschema-2/" TARGET="_top"><FONT FACE="sans-serif"><SPAN LANG="en"><I><B>XML
Schema Part 2: Datatypes</B></I></SPAN></FONT></A><FONT FACE="sans-serif"><SPAN LANG="en"><B>
.</B></SPAN></FONT><SPAN LANG="en"> Paul V. Biron and Ashok Malhotra.
2 May 2001. W3C.</SPAN></P>
</BODY>
</HTML>